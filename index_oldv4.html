<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Piece TCG Pack Ripper v5.2</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rye&display=swap');

        @font-face {
            font-family: 'OnePiece';  /* We give it a nickname */
            src: url('OnePiece.ttf');  
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'PirateKing';  /* We give it a nickname */
            src: url('PirateKing.ttf');  
            font-weight: normal;
            font-style: normal;
        }

        :root {
            --bg-color: #1a1a1d;
            --text-color: #ffffff;
            --card-width: 200px;
            --card-height: 280px;
            --primary-accent: #f7b731; /* Gold */
            --secondary-accent: #e74c3c; /* Red */
            --keep-accent: #2ecc71; /* Green */
            --save-accent: #3498db; /* Blue */
        }

        /* 1. RESET BODY (Clean slate) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
            background-color: #050505; /* Fallback */
        }

        /* 2. BACKGROUND CONTAINER (Fixed to viewport) */
        .background-fx {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -10; /* Send to very back */
            pointer-events: none; /* Let clicks pass through */
            
            /* THE GRADIENT: Night Sky fading into Deep Ocean */
            background: linear-gradient(
                to bottom, 
                #020005 0%,   /* Deep Space (Top) */
                #0b1023 60%,  /* Horizon Night */
                #0f2027 100%  /* The Ocean Surface (Bottom) */
            );
        }

        /* 3. FOG ANIMATION SHARED STYLES */
        .fog-layer {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            background-repeat: repeat-x;
            background-position: 0 bottom;
            will-change: background-position;
        }

        /* LAYER A: SLOW FOG (Far away, taller, transparent) */
        .fog-slow {
            height: 40vh; /* Covers bottom 60% of screen */
            background-image: url("fog.png");
            background-size: 2000px 100%; /* Stretch it out */
            opacity: 0.2;
            animation: fogScroll 120s linear infinite; /* Very slow drift */
        }

        /* LAYER B: FAST FOG (Close up, shorter, more visible) */
        .fog-fast {
            height: 20vh; /* Covers bottom 40% */
            background-image: url("fog.png");
            background-size: 1000px 100%; /* Tighter texture */
            opacity: 0.4;
            animation: fogScroll 40s linear infinite; /* Faster movement */
        }

        /* THE ANIMATION LOOP */
        @keyframes fogScroll {
            from { background-position-x: 0; }
            to { background-position-x: 4000px; } /* Must match or exceed background-size width for smooth loop */
        }

        /* 3. HEADERS & TITLES */
        h1, .pack-title, .binder-header, .collection-stats {
            font-family: 'Rye', serif; /* The "Wanted Poster" Look */
            letter-spacing: 2px;
            text-shadow: 3px 3px 0px #000;
        }

        /* Make the Title Gold & Impactful */
        h1 { 
            font-size: 2.5rem; 
            background: linear-gradient(to bottom, #ffd700, #b8860b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.3));
        }

        /* --- MENU BAR --- */
        .menu-bar { display: flex; gap: 10px; margin-bottom: 30px; flex-wrap: wrap; justify-content: center; z-index: 10; }
        .set-btn { background-color: #333; color: white; border: 2px solid #555; padding: 8px 16px; border-radius: 20px; cursor: pointer; transition: all 0.2s; font-weight: bold; }
        .set-btn:hover { border-color: var(--primary-accent); background-color: #444; }
        .set-btn.active { background-color: var(--primary-accent); color: black; border-color: var(--primary-accent); box-shadow: 0 0 10px var(--primary-accent); }
        .set-btn.retry { border-color: var(--secondary-accent); color: var(--secondary-accent); background: rgba(192, 57, 43, 0.1); }
        .toggle-btn { background-color: #444; color: #aaa; border: 1px dashed #777; padding: 8px 12px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; }
        .toggle-btn:hover { color: white; border-color: white; }

        /* --- PACK CONTROLS --- */
        .pack-controls { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px; z-index: 10; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 10px; border: 1px solid #333; }
        .pack-input-label { font-weight: bold; color: #ccc; }
        #packCountInput { background: #333; color: var(--primary-accent); border: 2px solid #555; padding: 8px; border-radius: 8px; width: 60px; text-align: center; font-size: 1.1rem; font-weight: bold; }
        
        .switch-label { display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-weight: bold; font-size: 0.9rem; }
        .switch-input { accent-color: var(--primary-accent); width: 18px; height: 18px; cursor: pointer; }

        /* --- 3D PACK AREA --- */
        .pack-area-wrapper { position: relative; width: 260px; height: 433px; margin-top: 2vh; margin-bottom: 50px; perspective: 1000px; z-index: 10; }
        .pack-stack { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        .pack-stack-item { position: absolute; width: 100%; height: 100%; background-size: cover; background-position: center; border-radius: 4px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); border: 1px solid #333; transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1); }
        .pack-container { width: 100%; height: 100%; position: relative; cursor: pointer; z-index: 10; transform: scale(1); transition: transform 0.2s; }
        .pack-tilter { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; will-change: transform; }
        .pack-half { position: absolute; width: 100%; height: 100%; background-size: cover; background-position: center; background-image: url(''); box-shadow: inset 0 0 40px rgba(0,0,0,0.8), 0 20px 40px rgba(0,0,0,0.6); border-radius: 4px; }
        .pack-half::before { content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(to bottom, rgba(255,255,255,0.3) 1px, transparent 1px) 0 0 / 100% 4px, linear-gradient(to top, rgba(255,255,255,0.3) 1px, transparent 1px) 0 100% / 100% 4px; background-repeat: repeat-x; height: 100%; mask-image: linear-gradient(to bottom, black 5%, transparent 5%, transparent 95%, black 95%); -webkit-mask-image: linear-gradient(to bottom, black 5%, transparent 5%, transparent 95%, black 95%); pointer-events: none; z-index: 2; }
        .pack-glare { position: absolute; top: 0; left: 0; bottom: 0; right: 0; background: linear-gradient(115deg, transparent 30%, rgba(255, 255, 255, 0.4) 45%, rgba(255, 255, 255, 0.7) 50%, rgba(255, 255, 255, 0.4) 55%, transparent 70%); background-size: 200% 200%; background-position: calc(var(--pack-x, 50) * 1%) calc(var(--pack-y, 50) * 1%); mix-blend-mode: overlay; opacity: 0.8; pointer-events: none; z-index: 3; }
        .pack-top { clip-path: polygon(0% 0%, 100% 0%, 100% 20%, 90% 25%, 80% 18%, 70% 26%, 60% 19%, 50% 27%, 40% 18%, 30% 26%, 20% 19%, 10% 25%, 0% 20%); z-index: 5; transform-origin: top center; }
        .pack-bottom { top: -1px; clip-path: polygon(0% 20%, 10% 25%, 20% 19%, 30% 26%, 40% 18%, 50% 27%, 60% 19%, 70% 26%, 80% 18%, 90% 25%, 100% 20%, 100% 100%, 0% 100%); z-index: 4; transform-origin: bottom center; }
        .pack-info { position: absolute; width: 100%; text-align: center; color: white; text-shadow: 0 2px 4px black, 0 0 10px black; pointer-events: none; z-index: 6; top: 75%; transition: opacity 0.3s; }
        .pack-title { font-weight: 900; font-size: 1.3rem; text-transform: uppercase; letter-spacing: 1px; }
        .pack-subtitle { font-size: 0.9rem; color: #ffd700; margin-top: 5px; font-weight: bold; }
        .click-hint { position: absolute; bottom: -50px; width: 100%; text-align: center; font-size: 1rem; color: #fff; animation: pulse 1.5s infinite; z-index: 6; font-weight: bold; text-shadow: 0 0 5px black; }

        /* --- ANIMATIONS --- */
        .pack-enter { animation: packDrop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes packDrop { 0% { transform: translateY(-50px) scale(0.9); opacity: 0; } 100% { transform: translateY(0) scale(1); opacity: 1; } }
        .shake-anim { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        .ripped-top { animation: ripTop 0.5s forwards ease-out; }
        .ripped-bottom { animation: ripBottom 0.5s forwards ease-out; }
        @keyframes ripTop { 0% { transform: translateY(0) rotate(0); opacity: 1; } 100% { transform: translateY(-150px) rotate(-15deg) scale(0.9); opacity: 0; } }
        @keyframes ripBottom { 0% { transform: translateY(0); } 100% { transform: translateY(100px) scale(0.95); opacity: 0; } }
        .flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 999; }
        .flash-anim { animation: flash 0.6s ease-out; }
        @keyframes flash { 0% { opacity: 0; } 10% { opacity: 0.8; } 100% { opacity: 0; } }

        /* GAME AREAS */
        #game-view, #binder-view { width: 100%; display: flex; flex-direction: column; align-items: center; }
        .cards-area { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; width: 100%; max-width: 1400px; z-index: 5; }

        /* PACK GROUPS (Split Mode) */
        .pack-group {
            width: 100%;
            background: rgba(255,255,255,0.03);
            border: 1px solid #444;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
            transition: 
                transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                opacity 0.4s ease-out,
                max-height 0.5s ease-in-out, 
                margin 0.5s ease-in-out,
                padding 0.5s ease-in-out,
                border 0.5s ease-in-out;
            max-height: 2000px; 
            overflow: hidden; 
            transform-origin: center center;
        }
        .pack-group.removing {
            max-height: 0; margin-bottom: 0; padding-top: 0; padding-bottom: 0; border-width: 0; opacity: 0; pointer-events: none; 
        }
        .pack-group-header { font-size: 1.2rem; color: #aaa; margin-bottom: 15px; width: 100%; text-align: left; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .pack-group-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; width: 100%; }
        .pack-group-actions { display: flex; gap: 10px; margin-top: 15px; }
        @keyframes fadeIn { to { opacity: 1; } }

        /* --- 3D CARD --- */
        .card { width: var(--card-width); height: var(--card-height); perspective: 1500px; display: none; cursor: pointer; margin-bottom: 10px; will-change: transform;}
        .card-tilter { width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 0.1s ease-out; will-change: transform; }
        .card-flipper { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .card-flipper.flipped { transform: rotateY(180deg); }
        .card-front, .card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 13px; overflow: hidden; box-shadow: 0 10px 20px rgba(0,0,0,0.4); background-color: #333; }
        .card-front { z-index: 2; transform: rotateY(0deg); }
        .card-back { transform: rotateY(180deg); background-size: cover; background-position: center; }

        /* ACTION BAR */
        .action-bar { display: flex; gap: 15px; margin-top: 30px; justify-content: center; flex-wrap: wrap; }
        .action-btn { padding: 8px 16px; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: bold; transition: transform 0.1s; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .action-btn:active { transform: scale(0.95); }
        .reveal-btn { background-color: #333; border: 2px solid white; }
        .keep-btn { background-color: var(--keep-accent); color: black; }
        .keep-btn:hover { background-color: #27ae60; }
        .toss-btn { background-color: var(--secondary-accent); }
        .toss-btn:hover { background-color: #c0392b; }

        /* BINDER */
        .binder-stats-row { display: flex; gap: 10px; flex-wrap: wrap; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; font-size: 0.85rem; color: #ccc; }
        .set-stat-pill { background: #333; border: 1px solid #555; padding: 4px 8px; border-radius: 4px; }
        .set-stat-pill span { color: var(--primary-accent); font-weight: bold; }
        .binder-controls { display: flex; gap: 10px; justify-content: center; width: 100%; flex-wrap: wrap; }
        .binder-select { background: #222; color: white; border: 1px solid #555; padding: 8px 12px; border-radius: 5px; font-family: inherit; cursor: pointer; }
        .collection-stats { font-size: 1.2rem; font-weight: bold; color: var(--primary-accent); }
        .nav-btn { background-color: #333; color: var(--primary-accent); border: 1px solid var(--primary-accent); padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .danger-btn { background-color: #e74c3c; color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.9rem; }

        /* --- BINDER HEADER (Refined Layout) --- */
        .binder-header {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(20, 24, 30, 0.9); /* Darker, cleaner background */
            border: 1px solid #333;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        /* ROW 1: Navigation & Stats */
        .binder-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
            margin-bottom: 5px;
        }

        /* ROW 2: Statistics Pills */
        .binder-stats-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 5px;
        }

        /* ROW 3: The Controls Container (Two-Line Layout) */
        #binder-controls {
            display: flex;
            flex-direction: column; /* Stack rows vertically */
            gap: 15px;
            width: 100%;
        }

        /* Control Group 1: Dropdowns */
        .control-row-main {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Control Group 2: Colors & Search */
        .control-row-secondary {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        /* Inputs & Selects */
        .binder-select {
            background: #222;
            color: white;
            border: 1px solid #555;
            padding: 10px 14px; /* Bigger touch targets */
            border-radius: 6px;
            font-family: inherit;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .binder-select:hover { border-color: var(--primary-accent); }

        /* Search Bar Specifics */
        #binderSearch {
            width: 200px;
            background-color: #1a1a1d;
            border-color: #444;
        }
        
        /* Stats Text */
        .collection-stats {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--primary-accent);
            text-shadow: 0 2px 4px black;
        }

        /* Buttons (Save/Load) */
        .data-btn {
            background-color: #333;
            color: var(--save-accent);
            border: 1px solid var(--save-accent);
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .data-btn:hover { background-color: var(--save-accent); color: white; }

        .nav-btn {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .nav-btn:hover { border-color: white; }

        /* BADGES */
        .count-badge { position: absolute; top: 8px; left: 8px; background-color: var(--secondary-accent); color: white; width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; border: 2px solid white; z-index: 20; box-shadow: 0 2px 5px rgba(0,0,0,0.8); }
        /* FIXED NEW BADGE (Green) */
        .new-badge { position: absolute; top: 8px; right: 8px; background-color: #2ecc71; color: #000; padding: 2px 6px; border-radius: 4px; font-weight: 900; font-size: 0.7rem; border: 2px solid white; z-index: 20; box-shadow: 0 0 10px #2ecc71; animation: pulse 1s infinite; }

        /* --- COLOR FILTERS --- */
        .color-filters {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 0 10px;
        }

        .color-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            opacity: 0.3; /* Dimmed by default */
            transition: all 0.2s;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.8);
        }

        .color-btn:hover {
            opacity: 0.7;
            transform: scale(1.1);
        }

        /* Active State: Full Brightness + Glow */
        .color-btn.active {
            opacity: 1;
            border-color: white;
            box-shadow: 0 0 10px currentColor;
            transform: scale(1.15);
        }

        /* Color Definitions */
        .c-red    { background-color: #e74c3c; color: #e74c3c; }
        .c-green  { background-color: #2ecc71; color: #2ecc71; }
        .c-blue   { background-color: #3498db; color: #3498db; }
        .c-purple { background-color: #9b59b6; color: #9b59b6; }
        .c-black  { background-color: #34495e; color: #34495e; }
        .c-yellow { background-color: #f1c40f; color: #f1c40f; }

        /* --- RESTRUCTURED TOOLTIP STYLES (Match Reference Image) --- */

        /* 1. Main Container */
        #cardTooltip {
            position: fixed;
            display: none;
            z-index: 999999;
            pointer-events: none; /* Crucial for smooth hovering */

            /* The Dark "Pirate UI" Background */
            background-color: rgba(20, 24, 30, 0.96);
            border: 2px solid #d4af37; /* A richer gold border */
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            
            /* Sizing & Spacing */
            padding: 12px 16px;
            min-width: 240px;
            max-width: 300px;
            
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.9rem;
            line-height: 1.4;
            
            animation: fadeIn 0.2s ease-out;
        }

        /* 2. Header (Card Name) */
        .tooltip-header {
            text-align: center;
            color: #ffd700; /* Bright Gold */
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(212, 175, 55, 0.3); /* Subtle gold separator */
            letter-spacing: 0.5px;
        }

        /* 3. Data Rows (Flexbox for Left/Right alignment) */
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            /* Subtle separator line between rows */
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Remove border from the very last stat row */
        .tooltip-row:last-of-type {
            border-bottom: none;
        }

        /* Left Side: Label */
        .tooltip-label {
            color: #aaa; /* Muted grey */
            font-weight: 500;
            margin-right: 10px;
        }

        /* Right Side: Value */
        .tooltip-val {
            text-align: right;
            color: #fff; /* Bright white */
            font-weight: 700;
        }

        /* 4. Description Section Container */
        .tooltip-desc-container {
            margin-top: 15px;
            padding-top: 10px;
            text-align: center;
        }

        /* The "DESCRIPTION" Title with lines on side */
        .tooltip-desc-title {
            display: flex;
            align-items: center;
            justify-content: center;
            
            color: #ffd700; /* Gold */
            font-weight: 700;
            font-size: 0.95rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        /* The subtle gold lines using pseudo-elements */
        .tooltip-desc-title::before,
        .tooltip-desc-title::after {
            content: "";
            flex: 1; /* Takes up remaining space */
            border-bottom: 1px solid rgba(212, 175, 55, 0.4);
            margin: 0 10px; /* Spacing between text and line */
        }

        /* The Body Text */
        .tooltip-desc-text {
            color: #e0e0e0; /* Off-white */
            font-style: italic;
            font-size: 0.85rem;
            padding: 0 5px;
        }

        /* RARITY BORDERS */
        .rarity-C .card-front { border: 4px solid #a9a9a9; }
        .rarity-UC .card-front { border: 4px solid #4caf50; }
        .rarity-R .card-front { border: 4px solid #3498db; }
        .rarity-SR .card-front { border: 4px solid #ffd700; box-shadow: 0 0 15px #ffd700; }
        .rarity-SEC .card-front { border: 4px solid #e74c3c; box-shadow: 0 0 20px #e74c3c; }
        .rarity-L .card-front { border: 4px solid #ffd700; }

        /* --- THE FIXED GLARE SYSTEM --- */
        .card-glare {
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            will-change: background-position, mask-image;

            /* 1. TEXTURE LAYER */
            background-image: url("https://www.transparenttextures.com/patterns/stardust.png");
            background-size: 100px 100px; 
            
            /* 2. THE MASK (The "Beam") */
            /* UPDATED: Tightened the spread. */
            /* Old: transparent 20% ... transparent 80% (Wide) */
            /* New: transparent 38% ... transparent 62% (Thin & Sharp) */
            -webkit-mask-image: linear-gradient(115deg, transparent 38%, black 48%, black 52%, transparent 62%);
            mask-image: linear-gradient(115deg, transparent 38%, black 48%, black 52%, transparent 62%);
            
            -webkit-mask-size: 200% 200%;
            mask-size: 200% 200%;
            
            -webkit-mask-position: calc(var(--pointer-x) * 1%) calc(var(--pointer-y) * 1%);
            mask-position: calc(var(--pointer-x) * 1%) calc(var(--pointer-y) * 1%);
            
            /* 3. BLEND MODE */
            mix-blend-mode: overlay;
            background-color: white; 
        }

        .card:hover .card-glare { opacity: 1; }

        /* --- SPECIFIC RARITIES --- */
        /* We change the background-color (tint) and the mask (beam shape) */

        /* RARE: Blue Tint */
        .glare-rare {
            background-color: #00bfff;
            mix-blend-mode: screen; /* Brighter */
        }

        /* SUPER RARE: Rainbow Tint + Diagonal Texture */
        .glare-super {
            background-image: url("https://www.transparenttextures.com/patterns/diagonal-striped-brick.png");
            /* Rainbow Gradient as the COLOR, not the mask */
            background: 
                linear-gradient(115deg, transparent 20%, rgba(255,0,0,0.8) 40%, rgba(255,215,0,0.8) 45%, rgba(0,255,0,0.8) 50%, rgba(0,0,255,0.8) 55%, transparent 80%),
                url("https://www.transparenttextures.com/patterns/diagonal-striped-brick.png");
            background-blend-mode: overlay; /* Blend rainbow onto texture */
            
            /* IMPORTANT: We must re-declare sizes/positions if we use the background shorthand above. */
            /* But to be safe, let's just use the Mask logic which is cleaner for movement. */
            
            /* RE-APPLY MOVEMENT LOGIC explicitly for this class to fix the "Stop Moving" bug */
            background-size: 200% 200%, 100px 100px;
            background-position: calc(var(--pointer-x) * 1%) calc(var(--pointer-y) * 1%), 0 0;
            
            mix-blend-mode: color-dodge;
        }

        /* SECRET / MANGA: High-Contrast "Etched" Magma */
        .glare-secret {
            /* 1. LAYERS: Texture First (Top), Gradient Second (Bottom) */
            background-image: 
                url("https://www.transparenttextures.com/patterns/diagmonds.png"), 
                linear-gradient(
                    115deg, 
                    transparent 20%, 
                    rgba(139, 0, 0, 0.8) 35%,   /* Dark Red */
                    rgba(255, 69, 0, 0.9) 40%,  /* Bright Orange */
                    rgba(255, 215, 0, 1) 45%,   /* Solid Gold */
                    rgba(255, 255, 255, 1) 50%, /* WHITE HOT */
                    rgba(255, 215, 0, 1) 55%,   /* Solid Gold */
                    rgba(255, 69, 0, 0.9) 60%,  /* Bright Orange */
                    rgba(139, 0, 0, 0.8) 65%,   /* Dark Red */
                    transparent 80%
                );

            /* 2. SIZING & POSITIONING (Must match order above!) */
            /* Texture: Tiled (4px), Fixed Position */
            /* Gradient: Double Size, Moves with Mouse */
            background-size: 50px 50px, 200% 200%;
            background-position: 0 0, calc(var(--pointer-x) * 1%) calc(var(--pointer-y) * 1%);

            /* 3. THE "ETCHING" (Blend the Texture into the Fire) */
            /* 'multiply' forces the dark lines of the carbon fiber to cut through the brightness */
            background-blend-mode: multiply; 

            /* 4. FINAL GLOW */
            mix-blend-mode: plus-lighter;
            filter: contrast(2.5); /* Boost contrast to pop the texture */
        }

        /* --- IMPACT SYSTEM --- */
        /* 1. SCREEN SHAKE (For the big hits) */
        .shake-screen { animation: shake-screen 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        
        @keyframes shake-screen {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* 2. VARIABLE FLASH SPEEDS */
        .flash-anim-fast { animation: flash 0.3s ease-out; }   /* Rare */
        .flash-anim-med { animation: flash 0.8s ease-out; }    /* SR */
        .flash-anim-long { animation: flash 2.5s ease-out; }   /* Manga/SEC */
        
        /* Ensure the flash overlay is setup correctly */
        .flash-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: white; opacity: 0; pointer-events: none; z-index: 999; 
        }

        /* --- WANTED POSTER STYLES --- */
        .wanted-wrapper {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); /* Darken background */
            z-index: 10000;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s;
        }

        .wanted-poster {
            width: 320px;
            background: #f4dec0; /* Paper Color */
            background-image: url("https://www.transparenttextures.com/patterns/cream-paper.png");
            padding: 20px 20px 10px 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.9), inset 0 0 40px rgba(139,69,19, 0.3);
            border: 2px solid #5e4b35;
            transform: scale(0.8) rotate(-2deg);
            animation: slamDown 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            position: relative;
        }
        
        /* The "Slam" Animation */
        @keyframes slamDown {
            0% { transform: scale(3) rotate(10deg); opacity: 0; }
            100% { transform: scale(1) rotate(-2deg); opacity: 1; }
        }

        .wanted-header {
            font-family: 'Rye', serif;
            font-size: 3.5rem;
            line-height: 1;
            color: #2e1c11;
            margin-bottom: 5px;
            letter-spacing: 5px;
            opacity: 0.9;
        }
        
        .wanted-sub {
            font-family: 'Rye', serif;
            font-size: 0.8rem;
            color: #2e1c11;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        /* 1. The Slot Container */
        .wanted-image-slot {
            width: 100%;
            height: 300px;
            /* CHANGED: Made transparent so the main poster paper texture shows through */
            background: transparent; 
            margin-bottom: 15px;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            /* Removed inset shadow so the paper looks flat */
        }
        
        /* 2. The "Ink" Image */
        .wanted-image-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Keep the whole card visible */
            
            /* THE "DRAWN" EFFECT: */
            /* 1. Grayscale it. 2. Crank contrast way up to make it look like black ink. 3. Slight brightness bump to ensure whites are pure white. */
            filter: grayscale(100%) contrast(250%) brightness(110%) sepia(30%);
            
            /* THE BLEND: */
            /* "Multiply" makes white transparent and dark colors burn into the background paper texture */
            mix-blend-mode: multiply; 
            
            /* Optional: Slight opacity to make it look like old printed ink */
            opacity: 0.9;
        }

        .wanted-name {
            font-family: 'Rye', serif;
            font-size: 1.8rem;
            color: #2e1c11;
            text-transform: uppercase;
            border-bottom: 2px solid #2e1c11;
            display: inline-block;
            padding: 0 20px 5px 20px;
            margin-bottom: 10px;
        }

        .wanted-bounty {
            font-family: 'Rye', serif;
            font-size: 1.4rem;
            color: #2e1c11;
            display: flex; justify-content: flex-start; align-items: center;
            padding-left: 20px;
        }
        
        .berry-symbol { font-size: 0.8em; margin-right: 10px; opacity: 0.7; }
        .belly-text { margin-left: auto; font-size: 0.8em; padding-right: 10px;}

        /* --- CARD PREVIEW MODAL --- */
        .preview-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Deep focus */
            z-index: 20000; /* Above everything */
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.2s ease-out;
            cursor: zoom-out;
        }

        .preview-content {
            position: relative;
            text-align: center;
            transform: scale(0.8);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* The High-Res Card */
        .preview-content img {
            max-height: 80vh; /* Keep it on screen */
            max-width: 90vw;
            border-radius: 15px; /* Use your --card-radius variable if you want */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        .preview-info {
            margin-top: 15px;
            color: white;
            text-shadow: 0 2px 4px black;
        }
        
        .preview-info h2 { margin: 0; font-family: 'Rye', serif; font-size: 2rem; letter-spacing: 2px; }
        .preview-info p { margin: 5px 0 0 0; font-size: 1.2rem; color: #ffd700; font-weight: bold; }

        @keyframes popIn {
            to { transform: scale(1); }
        }

        /* --- LOGO STYLES --- */
        .logo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
            cursor: pointer;
            z-index: 10;
            
            /* THE "SHIP ON WATER" ANIMATION */
            animation: bobbing 4s ease-in-out infinite;
        }

        .logo-main {
            font-family: 'PirateKing', 'Rye', serif;
            font-size: 6rem;
            line-height: 0.85; /* Squish it slightly for impact */
            letter-spacing: 0px;
            padding-left: 10px;
            padding-right: 10px;
            padding-top: 30px;
            
            /* THE ANIME "RED" GRADIENT */
            background: linear-gradient(to bottom, #ff5e62, #ff9966);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            
            /* DEEP SHADOW */
            filter: drop-shadow(0 5px 0px #2c1a0b);
        }

        .logo-sub {
            font-family: 'Rye', serif;
            font-size: 1.2rem;
            color: #ffd700; /* Gold */
            margin-top: 5px;
            letter-spacing: 4px;
            text-shadow: 2px 2px 0px #000;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0.9;
        }

        .logo-icon {
            font-size: 1rem;
            filter: drop-shadow(0 0 5px gold);
            animation: spinRock 3s ease-in-out infinite alternate;
        }

        /* --- ANIMATIONS --- */
        
        /* Gently floats up and down like a boat */
        @keyframes bobbing {
            0%, 100% { transform: translateY(0) rotate(-1deg); }
            50% { transform: translateY(-10px) rotate(1deg); }
        }

        /* Icons rock back and forth */
        @keyframes spinRock {
            from { transform: rotate(-15deg); }
            to { transform: rotate(15deg); }
        }

        /* --- MOBILE ADJUSTMENT --- */
        @media (max-width: 768px) {
            .logo-main { font-size: 2.8rem; }
            .logo-sub { font-size: 0.9rem; }
        }
        
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes popIn { 0% { transform: scale(0) rotateY(180deg); opacity: 0; } 60% { transform: scale(1.1) rotateY(0deg); opacity: 1; } 100% { transform: scale(1) rotateY(0deg); opacity: 1; } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
        .shake-anim { animation: shake 0.5s; animation-iteration-count: 1; }

        /* PARTICLES */
        .particle { position: fixed; width: 8px; height: 8px; background-color: gold; pointer-events: none; border-radius: 50%; z-index: 9999; animation: fadeOut 1s forwards ease-out; }
        @keyframes fadeOut { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
        @keyframes legendary-pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); border-color: #ffd700; } 50% { box-shadow: 0 0 50px 20px rgba(255, 215, 0, 0); border-color: #ffffff; } 100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); border-color: #ffd700; } }
        .legendary-reveal .card-front { animation: legendary-pulse 1.2s infinite; border: 4px solid #ffd700 !important; z-index: 100; }

        /* CUSTOM STEPPER STYLES */
        .stepper-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stepper-btn {
            background-color: #333;
            color: var(--primary-accent); /* Gold text */
            border: 2px solid #555;
            border-radius: 8px;
            width: 40px;
            height: 40px; /* Large touch target */
            font-size: 1.5rem;
            line-height: 1;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.1s;
        }
        
        .stepper-btn:active {
            background-color: #555;
            transform: scale(0.95);
        }

        /* Clean up the Input Field */
        #packCountInput {
            background: #222;
            color: white;
            border: 2px solid #555;
            padding: 5px;
            border-radius: 8px;
            width: 50px;
            height: 40px; /* Match button height */
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            -moz-appearance: textfield; /* Remove Firefox arrows */
        }
        
        /* Remove native arrows on Chrome/Safari/Edge */
        #packCountInput::-webkit-inner-spin-button, 
        #packCountInput::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }

        /* --- MOBILE OPTIMIZATIONS (Max Width 768px) --- */
        @media (max-width: 768px) {
            
            /* 1. FLUID CARD GRID */
            /* Fits 2 cards per row on mobile screens */
            :root {
                --card-width: 44vw; /* 44% of viewport width */
                --card-height: 61vw; /* Maintain aspect ratio roughly */
            }
            
            .cards-area {
                gap: 10px;
                padding-bottom: 80px; /* Space for fixed buttons if added later */
            }

            /* 2. SCROLLABLE MENU */
            /* Turns the multi-line buttons into a tidy scroll ribbon */
            .menu-bar {
                flex-wrap: nowrap;
                overflow-x: auto;
                justify-content: flex-start;
                width: 100%;
                padding-bottom: 10px;
                -webkit-overflow-scrolling: touch; /* Smooth scroll on iOS */
            }
            
            /* Hide scrollbar for cleaner look */
            .menu-bar::-webkit-scrollbar { display: none; } 
            
            .set-btn, .toggle-btn {
                flex-shrink: 0; /* Prevents buttons from squishing */
                font-size: 0.85rem;
                padding: 8px 12px;
            }

            /* 3. RESPONSIVE PACK AREA */
            /* Scales the 3D pack down so it fits on narrow screens */
            .pack-area-wrapper {
                transform: scale(0.85);
                margin-top: 0;
                margin-bottom: 20px;
            }

            /* 4. COMPACT CONTROLS */
            .pack-controls {
                flex-wrap: wrap;
                gap: 10px;
                width: 90%;
            }
            
            /* 5. STACKED BINDER CONTROLS */
            .binder-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .binder-select {
                width: 100% !important; /* Force full width on phones */
                margin-bottom: 5px;
            }

            /* 6. BIGGER TOUCH TARGETS */
            .action-btn {
                padding: 12px 20px; /* Fat finger friendly */
                font-size: 1.1rem;
            }
        }
        /* --- ULTRA NARROW SCREENS (Single Column) --- */
        @media (max-width: 480px) {
            :root {
                --card-width: 85vw;   /* Big Cards */
                --card-height: 119vw; 
            }
            
            .cards-area {
                justify-content: center;
            }

            /* NEW: Soften the corners when cards are huge */
            .card, .card-inner, .card-front, .card-back, .card-glare {
                border-radius: 25px !important; /* Bump up from the default (usually 10-12px) */
            }
        }
        /* SMART TOOLTIP STYLES */
        .mobile-tooltip {
            position: fixed !important;
            top: auto !important;
            bottom: 0 !important;
            left: 0 !important;
            width: 100%;
            max-width: 100%;
            border-radius: 12px 12px 0 0;
            border: none;
            border-top: 2px solid var(--primary-accent);
            background: rgba(20, 20, 25, 0.98);
            box-shadow: 0 -5px 30px rgba(0,0,0,0.9);
            transform: translateY(0);
            animation: slideUp 0.25s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 10000;
            padding: 20px;
            padding-bottom: 30px; /* Safe area for swipe bars */
        }
        
        @keyframes slideUp { 
            from { transform: translateY(100%); } 
            to { transform: translateY(0); } 
        }
    </style>
</head>
<body>

    <div class="background-fx">
        <div class="fog-layer fog-slow"></div>
        <div class="fog-layer fog-fast"></div>
    </div>

    <div class="logo-container" onclick="playSound('HOVER')">
        <div class="logo-main">ONe PIeCE</div>
        <div class="logo-sub">
            <span class="logo-icon">‚öì</span> PACK RIPPER <span class="logo-icon">‚öì</span>
        </div>
    </div>

    <div class="menu-bar" id="menuBar"></div>

    <div class="flash-overlay" id="flashOverlay"></div>

    <div id="cardPreviewOverlay" class="preview-overlay" style="display:none;" onclick="closePreview()">
        <div class="preview-content">
            <img id="previewImage" src="" alt="Card Preview">
            <div class="preview-info">
                <h2 id="previewTitle">Card Name</h2>
                <p id="previewPrice">$0.00</p>
            </div>
        </div>
    </div>

    <div id="wantedOverlay" class="wanted-wrapper" style="display:none;" onclick="closeWanted()">
        <div class="wanted-poster">
            <div class="wanted-header">WANTED</div>
            <div class="wanted-sub">DEAD OR ALIVE</div>
            <div class="wanted-image-slot" id="wantedImageSlot">
                </div>
            <div class="wanted-name" id="wantedName">MONKEY.D.LUFFY</div>
            <div class="wanted-bounty">
                <span class="berry-symbol">‡∏ø</span>
                <span id="wantedValue">5,000,000,000</span>
                <span class="belly-text">-</span>
            </div>
        </div>
    </div>

    <div id="game-view">
        
        <div class="pack-controls">
            <span class="pack-input-label">Packs:</span>
            
            <div class="stepper-wrapper">
                <button class="stepper-btn" onclick="adjustPackCount(-1)">‚àí</button>
                <input type="number" id="packCountInput" value="1" min="1" max="24" onchange="updatePackVisuals()">
                <button class="stepper-btn" onclick="adjustPackCount(1)">+</button>
            </div>
            
            <label class="switch-label">
                <input type="checkbox" id="splitToggle" class="switch-input">
                Split Packs
            </label>

            <button id="gyroBtn" class="set-btn" style="display:none; background:#e67e22; border-color:#d35400;" onclick="requestGyro()">Enable Tilt üì±</button>
        </div>

        <div class="pack-area-wrapper" id="packWrapper">
            <div id="packStack" class="pack-stack"></div>
            <div class="pack-container" id="pack">
                <div class="pack-tilter" id="packTilter" onclick="openPack()">
                    <div class="pack-wrapper">
                        <div class="pack-half pack-top" id="packTop"><div class="pack-glare"></div></div>
                        <div class="pack-half pack-bottom" id="packBottom">
                            <div class="pack-glare"></div>
                            <div class="pack-info" id="packInfo">
                                <div class="pack-title" id="packTitle">Loading...</div>
                                <div class="pack-subtitle" id="packSubtitle">Please Wait</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="click-hint">CLICK TO OPEN</div>
            </div>
        </div>

        <div class="cards-area" id="cardsArea"></div>

        <div class="action-bar" id="actionBar" style="display:none;">
            <button class="action-btn reveal-btn" id="revealBtn" onclick="flipAll()">Reveal All</button>
            <button class="action-btn keep-btn" id="keepBtn" onclick="keepCards()">Keep All</button>
            <button class="action-btn toss-btn" id="tossBtn" onclick="tossCards()">Toss (Reset)</button>
        </div>
    </div>

    <div id="binder-view" style="display:none;">
        <div class="binder-header">
            
            <div class="binder-top-row">
                <button class="nav-btn" onclick="toggleBinder(false)">‚Üê Back to Packs</button>
                <div class="collection-stats" id="collectionStats">Total: 0</div>
                <div class="data-controls">
                    <button class="data-btn" onclick="exportSave()">üíæ Save</button>
                    <button class="data-btn" onclick="document.getElementById('importFile').click()">üìÇ Load</button>
                    <button class="danger-btn" onclick="wipeCollection()">üíÄ Reset</button>
                    <input type="file" id="importFile" style="display:none" onchange="importSave(this)">
                </div>
            </div>

            <div class="binder-stats-row" id="binderStats"></div>

            <div id="binder-controls">
                
                <div class="control-row-main">
                    <select id="filterSet" class="binder-select" onchange="renderBinder()">
                        <option value="ALL">All Sets</option>
                        </select>

                    <select id="filterRarity" class="binder-select" onchange="renderBinder()">
                        <option value="ALL">All Rarities</option>
                        <option value="MANGA">üè¥‚Äç‚ò†Ô∏è Manga Rares</option>
                        <option value="TREASURE">üèÜ Treasure Rares</option>
                        <option value="AA">‚ú® Alt Arts / Parallels</option>
                        <option value="SPECIAL">üî• Special / Box Toppers</option>
                        <option value="SEC">Secret Rare</option>
                        <option value="L">Leader</option>
                        <option value="SR">Super Rare</option>
                        <option value="R">Rare</option>
                        <option value="UC">Uncommon</option>
                        <option value="C">Common</option>
                        <option value="DON">DON!! Cards</option>
                    </select>

                    <select id="sortOrder" class="binder-select" onchange="renderBinder()">
                        <option value="RARITY">‚ú® Sort: Rarity (Default)</option>
                        <option value="PRICE_DESC">üí∞ Bounty: Highest First</option>
                        <option value="PRICE_ASC">üí∏ Bounty: Lowest First</option>
                        <option value="NEWEST">üÜï Date: Newest First</option>
                        <option value="NUMBER">üî¢ Card Number</option>
                    </select>
                </div>

                <div class="control-row-secondary">
                    <span style="color:#777; font-size:0.8em; font-weight:bold; text-transform:uppercase;">Filter Color:</span>
                    
                    <div class="color-filters">
                        <div class="color-btn c-red"    onclick="toggleColor('Red', this)"    title="Red"></div>
                        <div class="color-btn c-green"  onclick="toggleColor('Green', this)"  title="Green"></div>
                        <div class="color-btn c-blue"   onclick="toggleColor('Blue', this)"   title="Blue"></div>
                        <div class="color-btn c-purple" onclick="toggleColor('Purple', this)" title="Purple"></div>
                        <div class="color-btn c-black"  onclick="toggleColor('Black', this)"  title="Black"></div>
                        <div class="color-btn c-yellow" onclick="toggleColor('Yellow', this)" title="Yellow"></div>
                    </div>

                    <input type="text" id="binderSearch" class="binder-select" placeholder="Search Name..." oninput="renderBinder()">
                </div>

            </div>
        </div>
        <div class="cards-area" id="binderGrid"></div>
    </div>

    <div id="global-tooltip"></div>
    <div id="cardTooltip" class="tooltip-container" style="display: none;"></div>

<script>
    // --- 1. CONFIGURATION ---
    const CACHE_VERSION = "v28"; // Bumped for safe save

    // CONFIGURABLE SPEEDS (ms)
    const SPEED = {
        SINGLE: 200, // Single Pack
        BULK: 40,    // 2-10 Packs
        TURBO: 10    // 11+ Packs
    };

    // ANIMATION TIMINGS (ms)
    const DELAY = {
        SHAKE: 500,  // How long to shake before ripping
        REVEAL: 400  // Time from Rip start to cards appearing
    };

    const CARD_BACKS = { GENERIC: "op_back_gen.jpg", LEADER: "op_back_lead.jpg", DON: "op_back_don.jpg" };
    const PACK_IMAGES = { DEFAULT: "pack_blank.png", OP01: "pack_rd.png", OP02: "pack_pw.png", OP03: "pack_ps.png", OP04: "pack_ki.png", OP05: "pack_ane.png", OP06: "pack_wc.png", OP07: "pack_fyf.png", OP08: "pack_tl.png", OP09: "pack_enw.png", OP10: "pack_rb.png", OP11: "pack_fds.png", OP12: "pack_lm.png", OP13: "pack_chw.png", OP14: "pack_ass.png", EB01: "pack_eb01.png", EB02: "pack_eb02.png", EB03: "pack_eb03.png", PRB01: "pack_prb1.png", PRB02: "pack_prb2.png" };
    const SOUND_ASSETS = { 
        OPEN: "packRip.mp3", 
        FLIP: "cardFlip.mp3", 
        HOVER: "over.mp3", 
        DEAL: "cardDeal.mp3", 
        DROP: "packDrop.mp3",

        // --- NEW TIERED REVEAL SOUNDS ---
        HIT_R: "rareFlip.mp3",      // Light hit
        HIT_SR: "srFlip.mp3",       // Medium hit
        HIT_SEC: "secFlip.mp3",     // Heavy hit (Bass)
        HIT_GOD: "mangaFlip.mp3"      // Massive hit (Choir/Explosion)
    };
    const DATA_SOURCES = [
        { name: "OP-01 Romance Dawn", url: "https://tcgcsv.com/tcgplayer/68/3188/products" },
        { name: "OP-02 Paramount War", url: "https://tcgcsv.com/tcgplayer/68/17698/products" },
        { name: "OP-03 Pillars of Strength", url: "https://tcgcsv.com/tcgplayer/68/22890/products" },
        { name: "OP-04 Kingdoms of Intrigue", url: "https://tcgcsv.com/tcgplayer/68/23024/products" },
        { name: "OP-05 Awakening of the New Era", url: "https://tcgcsv.com/tcgplayer/68/23213/products" },
        { name: "OP-06 Wings of the Captain", url: "https://tcgcsv.com/tcgplayer/68/23272/products" },
        { name: "OP-07 500 Years into the Future", url: "https://tcgcsv.com/tcgplayer/68/23387/products" },
        { name: "OP-08 Two Legends", url: "https://tcgcsv.com/tcgplayer/68/23462/products" },
        { name: "OP-09 Emperors in the New World", url: "https://tcgcsv.com/tcgplayer/68/23589/products" },
        { name: "OP-10 Royal Blood", url: "https://tcgcsv.com/tcgplayer/68/23766/products" },
        { name: "OP-11 A Fist of Divine Speed", url: "https://tcgcsv.com/tcgplayer/68/24241/products" },
        { name: "OP-12 Legacy of the Master", url: "https://tcgcsv.com/tcgplayer/68/24302/products" },
        { name: "OP-13 Carrying on His Will", url: "https://tcgcsv.com/tcgplayer/68/24303/products" },
        { name: "OP-14 The Azure Sea's Seven", url: "https://tcgcsv.com/tcgplayer/68/24537/products" },
        { name: "EB-01 Memorial Collection", url: "https://tcgcsv.com/tcgplayer/68/23333/products" },
        { name: "EB-02 Anime 25th Collection", url: "https://tcgcsv.com/tcgplayer/68/23834/products" },
        { name: "EB-03 One Piece Heroines Edition", url: "https://tcgcsv.com/tcgplayer/68/24545/products" },
        { name: "PRB-01 One Piece Card The Best", url: "https://tcgcsv.com/tcgplayer/68/23496/products" },
        { name: "PRB-02 One Piece Card The Best vol 2", url: "https://tcgcsv.com/tcgplayer/68/24305/products" }
    ];
    const ALLOWED_PREFIXES = DATA_SOURCES.map(ds => ds.name.split(" ")[0].replace("-", ""));

    // --- 2. STATE ---
    let setPools = []; 
    let masterPool = { common: [], uncommon: [], rare: [], superRare: [], secretRare: [], leader: [], manga: [], altArt: [], boxTopper: [], special: [], treasure: [], don: [] };
    let activePool = null; 
    let userCollection = {}; 
    let limboBatches = []; 
    let activeCardRect = null;
    let activePackRect = null;
    let showPackText = true;
    let gyroActive = false;
    let globalMouseX = 0;
    let globalMouseY = 0;
    let activeColors = new Set();
    let binderScrollObserver = null;
    let currentBinderKeys = []; // Stores the full list of filtered keys
    let renderedCount = 0;      // How many we have shown so far
    const BATCH_SIZE = 50;      // How many to show at a time

    // DOM References
    const packContainer = document.getElementById('pack');
    const packStack = document.getElementById('packStack');
    const packWrapper = document.getElementById('packWrapper');
    const packTop = document.getElementById('packTop');
    const packBottom = document.getElementById('packBottom');
    const packTilter = document.getElementById('packTilter');
    const packInfo = document.getElementById('packInfo');
    const packTitle = document.getElementById('packTitle');
    const packSubtitle = document.getElementById('packSubtitle');
    const flashOverlay = document.getElementById('flashOverlay');
    const menuBar = document.getElementById('menuBar');
    const cardsArea = document.getElementById('cardsArea');
    const actionBar = document.getElementById('actionBar');
    
    // Global Buttons
    const revealBtn = document.getElementById('revealBtn');
    const keepBtn = document.getElementById('keepBtn');
    const tossBtn = document.getElementById('tossBtn');

    // const globalTooltip = document.getElementById('global-tooltip');
    const gameView = document.getElementById('game-view');
    const binderView = document.getElementById('binder-view');
    const binderGrid = document.getElementById('binderGrid');
    const collectionStats = document.getElementById('collectionStats');
    const binderStats = document.getElementById('binderStats');
    const filterSet = document.getElementById('filterSet');
    const filterRarity = document.getElementById('filterRarity');
    const binderSearch = document.getElementById('binderSearch');
    const packCountInput = document.getElementById('packCountInput');
    const splitToggle = document.getElementById('splitToggle');

    // --- 3. HELPER FUNCTIONS ---
    function cleanupStorage() {
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('optcg_cache_') && !key.includes(CACHE_VERSION)) localStorage.removeItem(key);
        });
    }

    function analyzeTags(name, cleanName, extendedData) {
        const n = (name + " " + cleanName).toLowerCase();
        let rVal = "";
        if (extendedData) {
            const rObj = extendedData.find(i => i.name === "Rarity");
            if (rObj && rObj.value) rVal = rObj.value.toLowerCase();
        }

        // NEW: Check specifically for Gold DONs
        const isGoldDon = (n.includes("don") && n.includes("gold")) || 
                          (n.includes("don") && (rVal.includes("special") || rVal.includes("sp")));

        const tags = {
            isManga: n.includes("manga") || rVal.includes("manga"),
            isParallel: n.includes("parallel") || n.includes("(aa)") || n.includes("alternate art") || n.includes("alt art") || rVal.includes("parallel") || rVal.includes("aa"),
            isBoxTopper: n.includes("box topper") || n.includes("promotion pack"),
            isSpecial: n.includes("anniversary") || n.includes("special") || n.includes("event") || n.includes("(sp)") || rVal.includes("sp"),
            isSignature: n.includes("signature") || n.includes("stamped"),
            isTreasure: rVal.includes("tr"),
            
            // Add our new tag
            isGoldDon: isGoldDon
        };
        return tags;
    }

    let isMuted = localStorage.getItem('optcg_muted') === 'true';
    function playSound(key) {
        if (isMuted) return;
        const url = SOUND_ASSETS[key];
        if (!url) return;
        
        const audio = new Audio(url);
        audio.volume = 0.5; // Base volume

        // --- EXISTING VOLUMES ---
        if (key === 'HOVER') audio.volume = 0.2; 
        if (key === 'OPEN') audio.volume = 0.6;
        if (key === 'DROP') audio.volume = 0.4;
        
        // --- NEW TIERED VOLUMES ---
        if (key === 'HIT_R') audio.volume = 0.6;    // Rare (Light)
        if (key === 'HIT_SR') audio.volume = 0.7;   // Super Rare (Medium)
        if (key === 'HIT_SEC') audio.volume = 0.85; // Secret (Heavy)
        if (key === 'HIT_GOD') audio.volume = 1.0;  // God (Max)

        // --- PITCH VARIANCE ---
        let variance = 0.1; 
        
        // Keep musical sounds (Rare hits) closer to original pitch
        if (key === 'RARE' || key.startsWith('HIT_')) variance = 0.05; 
        
        // Allow more randomness for physical sounds
        if (key === 'DEAL' || key === 'FLIP') variance = 0.15; 
        
        const rate = 1.0 - variance + (Math.random() * (variance * 2));
        audio.playbackRate = rate;
        
        audio.play().catch(e => { });
    }

    function determineBackType(rarityStr, extendedData) {
        let isLeader = false;
        let isDon = false;
        if (rarityStr && (rarityStr === 'L' || rarityStr.includes('LEADER'))) isLeader = true;
        if (extendedData && Array.isArray(extendedData)) {
            extendedData.forEach(item => {
                const n = item.name.toLowerCase();
                const v = item.value ? item.value.toString().toUpperCase().trim() : "";
                if (n === 'rarity' || n === 'cardtype' || n === 'card type' || n === 'type') {
                    if (v.includes('LEADER')) isLeader = true;
                    if (v.includes('DON')) isDon = true;
                }
            });
        }
        if (isDon) return 'DON';
        if (isLeader) return 'LEADER';
        return 'GENERIC';
    }

    // --- 4. INITIALIZATION ---
    async function init() {
        packTitle.innerText = "Loading...";
        cleanupStorage();
        document.body.addEventListener('click', () => {
            const context = new (window.AudioContext || window.webkitAudioContext)();
            if (context.state === 'suspended') context.resume();
        }, { once: true });

        DATA_SOURCES.forEach(source => {
            const opt = document.createElement('option');
            opt.innerText = source.name;
            const code = source.name.split(" ")[0].replace("-", ""); 
            opt.value = code; 
            filterSet.appendChild(opt);
        });
        const otherOpt = document.createElement('option');
        otherOpt.innerText = "Other / Promos / Starters";
        otherOpt.value = "OTHER";
        filterSet.appendChild(otherOpt);

        const jobs = DATA_SOURCES.map(async (source, index) => {
            const pool = await fetchAndParse(source.url, source.name, source.name.split(" ")[0].replace("-", ""));
            if(pool.error) return { name: source.name, error: true, url: source.url, count: 0 };
            return { name: source.name, pool: pool, count: countTotal(pool) };
        });

        const results = await Promise.all(jobs);
        setPools = results;
        results.forEach((result, index) => { if(!result.error && result.count > 0) mergeIntoMaster(result.pool); });

        // --- SAFE HYDRATION ---
        const savedData = localStorage.getItem('optcg_collection');
        if (savedData) {
            try { 
                const rawSave = JSON.parse(savedData);
                userCollection = {}; 
                Object.keys(rawSave).forEach(key => {
                    const savedItem = rawSave[key];
                    let foundCard = null;
                    const pools = ['common','uncommon','rare','superRare','secretRare','leader','manga','altArt','boxTopper','special','treasure','don'];
                    for (const p of pools) {
                        if (masterPool[p]) {
                            const match = masterPool[p].find(c => String(c.id) === String(key) || c.name === key);
                            if (match) { foundCard = match; break; }
                        }
                    }
                    // SAFEGUARD: If card not found in DB (e.g., fetch error), create placeholder so it isn't deleted.
                    if (foundCard) {
                        foundCard.tags = analyzeTags(foundCard.name, "", foundCard.extendedData);
                        userCollection[key] = { count: savedItem.count || 1, isNew: savedItem.isNew || false, data: foundCard };
                    } else {
                        console.warn(`Card ${key} not found in database. Creating placeholder.`);
                        userCollection[key] = {
                            count: savedItem.count || 1,
                            isNew: savedItem.isNew || false,
                            data: {
                                id: key,
                                name: "Loading Error (" + key + ")",
                                image: "https://placehold.co/200x280?text=Error",
                                rarity: "COMMON",
                                setID: savedItem.setID || "OTHER",
                                extendedData: [],
                                backType: "GENERIC"
                            }
                        };
                    }
                });
                if(Object.keys(userCollection).length > 0) saveCollection(); 
            } catch(e) { userCollection = {}; }
        }

        createMenu();
        // --- 3D PACK MOUSE EVENTS (Desktop Only) ---
        if(packContainer && packTilter) {
            packContainer.addEventListener('mouseenter', () => {
                if (gyroActive) return; // DISABLE ON MOBILE
                activePackRect = packContainer.getBoundingClientRect();
                packTilter.style.transition = 'none';
            });
            
            packContainer.addEventListener('mousemove', (e) => {
                if (gyroActive) return; // DISABLE ON MOBILE
                if(!activePackRect) return;
                const x = e.clientX - activePackRect.left;
                const y = e.clientY - activePackRect.top;
                const xPercent = (x / activePackRect.width) * 100;
                const yPercent = (y / activePackRect.height) * 100;
                
                packTilter.style.setProperty('--pack-x', xPercent);
                packTilter.style.setProperty('--pack-y', yPercent);
                
                const rotateX = ((y - activePackRect.height/2) / (activePackRect.height/2)) * -15; 
                const rotateY = ((x - activePackRect.width/2) / (activePackRect.width/2)) * 15;
                packTilter.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            });
            
            packContainer.addEventListener('mouseleave', () => {
                packTilter.style.transition = 'transform 0.5s ease-out';
                packTilter.style.transform = `rotateX(0deg) rotateY(0deg)`;
                activePackRect = null;
            });
        }
        const validIndex = setPools.findIndex(s => !s.error);
        if(validIndex >= 0) selectSet(validIndex); else selectSet(-1);
        
        // --- GLOBAL MOUSE TRACKING (UPDATED) ---
        document.addEventListener('mousemove', (e) => {
            // FIX 1: Use Viewport Coordinates (clientX) instead of Page (pageX)
            globalMouseX = e.clientX;
            globalMouseY = e.clientY;

            // FIX 2: Force Tooltip Update
            // This prevents "drifting" if you move the mouse while scrolled
            const tooltipEl = document.getElementById('cardTooltip');
            if (tooltipEl && tooltipEl.style.display === 'block') {
                moveTooltip(globalMouseX, globalMouseY);
            }
        });

        // FIX 3: Hide Tooltip on Scroll
        window.addEventListener('scroll', () => {
            if (typeof hideTooltip === 'function') hideTooltip();
        }, { passive: true });

    }

    // --- 5. PARSING ---
    // --- 5. PARSING (UPDATED: Now fetches Prices too!) ---
    async function fetchAndParse(url, setName, currentSetCode) {
        const cacheKey = 'optcg_cache_' + CACHE_VERSION + '_' + setName;
        const cached = localStorage.getItem(cacheKey);
        
        // If we have valid cached data, return it immediately
        if(cached) return JSON.parse(cached);

        let localPool = { common: [], uncommon: [], rare: [], superRare: [], secretRare: [], leader: [], manga: [], altArt: [], boxTopper: [], special: [], treasure: [], don: [] };
        
        try {
            // 1. CONSTRUCT URLs
            // We need both the Product list (Images/Names) and the Price list (Market Value)
            const productsUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
            const pricesUrlRaw = url.replace('products', 'prices'); // Swap the endpoint
            const pricesUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(pricesUrlRaw)}`;

            // 2. DUAL FETCH (Get both at the same time)
            const [prodRes, priceRes] = await Promise.all([
                fetch(productsUrl),
                fetch(pricesUrl)
            ]);

            if (!prodRes.ok) throw new Error("Proxy error on products");
            // Note: If price fetch fails, we can still continue, but we'll check validity below.

            const prodData = await prodRes.json();
            const priceData = await priceRes.json(); // This might be empty or fail if API is down, we handle that.

            let rawList = prodData.results || prodData.cards || (Array.isArray(prodData) ? prodData : []);

            // 3. CREATE PRICE MAP
            // We make a lookup table: { "productId": 0.50 }
            const priceMap = {};
            if (priceData && priceData.results) {
                priceData.results.forEach(p => {
                    // We prioritize marketPrice -> midPrice -> lowPrice
                    priceMap[p.productId] = p.marketPrice || p.midPrice || p.lowPrice || 0;
                });
            }

            // 4. PROCESS CARDS
            // Filter out unrelated groups (same logic as before)
            const groupCounts = {}; let dominantGroupId = null; let maxCount = 0;
            rawList.forEach(c => { if (c.groupId) { groupCounts[c.groupId] = (groupCounts[c.groupId] || 0) + 1; if (groupCounts[c.groupId] > maxCount) { maxCount = groupCounts[c.groupId]; dominantGroupId = c.groupId; } } });

            rawList.forEach(rawCard => {
                if (!rawCard.extendedData || rawCard.extendedData.length === 0) return;
                if (dominantGroupId && rawCard.groupId !== dominantGroupId) return; 

                const name = rawCard.name || rawCard.cleanName || "Unknown";
                const cleanName = rawCard.cleanName || "";
                const id = rawCard.productId || rawCard.id || "000";
                const image = rawCard.imageUrl || rawCard.image || "https://placehold.co/200x280?text=No+Image";
                const extendedData = rawCard.extendedData || []; 
                let setID = "OTHER"; let displayNumber = id; 
                
                const numEntry = extendedData.find(i => i.name === "Number");
                if(numEntry && numEntry.value) {
                    displayNumber = numEntry.value; const rawPrefix = numEntry.value.split('-')[0];
                    if(ALLOWED_PREFIXES.includes(rawPrefix)) { setID = rawPrefix; } else { setID = 'OTHER'; }
                }

                // 5. MERGE PRICE (The New Step)
                // We look up the price using the ID and attach it to our clean card object
                const marketPrice = priceMap[rawCard.productId] || 0;

                const tags = analyzeTags(name, cleanName, extendedData);
                let rarityStr = "Common";
                if (extendedData) { const r = extendedData.find(item => item.name === "Rarity"); if (r) rarityStr = r.value; } 
                else if (rawCard.rarity) rarityStr = rawCard.rarity;
                rarityStr = rarityStr.toUpperCase();

                const backType = determineBackType(rarityStr, extendedData);
                
                // Add 'marketPrice' to this object
                const card = { name, id, displayNumber, image, rarity: rarityStr, extendedData, setID, backType, tags, marketPrice };

                // Sort into pools
                if (tags.isManga) localPool.manga.push(card);
                else if (tags.isTreasure) localPool.treasure.push(card);
                else if (tags.isBoxTopper) localPool.boxTopper.push(card);
                else if (tags.isSpecial) localPool.special.push(card);
                else if (tags.isParallel) localPool.altArt.push(card);
                else if (backType === 'DON') localPool.don.push(card);
                else {
                    if (rarityStr === 'UC' || rarityStr.includes("UNCOMMON")) localPool.uncommon.push(card);
                    else if (rarityStr === 'SR' || rarityStr.includes("SUPER")) localPool.superRare.push(card);
                    else if (rarityStr === 'SEC' || rarityStr.includes("SECRET")) localPool.secretRare.push(card);
                    else if (rarityStr === 'L' || rarityStr.includes("LEADER")) localPool.leader.push(card);
                    else if (rarityStr === 'R' || rarityStr.includes("RARE")) localPool.rare.push(card);
                    else if (rarityStr === 'TR' || rarityStr === 'SPECIAL') localPool.special.push(card); 
                    else localPool.common.push(card);
                }
            });

            try { localStorage.setItem(cacheKey, JSON.stringify(localPool)); } catch(e) {}
            return localPool;

        } catch (err) { 
            console.error("Fetch Error:", err);
            return { error: true }; 
        }
    }

    async function retryLoad(index) {
        const source = DATA_SOURCES[index];
        const btn = document.getElementById(`btn-${index}`);
        if(btn) btn.innerText = "Loading...";
        
        // Re-attempt the fetch
        const pool = await fetchAndParse(source.url, source.name, source.name.split(" ")[0].replace("-", ""));
        
        if(pool.error) {
            if(btn) btn.innerText = "Retry " + source.name.split(" ")[0];
            alert("Retry failed. The proxy might be busy, please try again in a moment.");
        } else {
            // Success! Update data and UI
            setPools[index] = { name: source.name, pool: pool, count: countTotal(pool) };
            mergeIntoMaster(pool);
            createMenu(); 
            selectSet(index); 
            alert(`${source.name} loaded successfully!`);
        }
    }

    function mergeIntoMaster(pool) {
        masterPool.common.push(...pool.common); masterPool.uncommon.push(...pool.uncommon); masterPool.rare.push(...pool.rare);
        masterPool.superRare.push(...pool.superRare); masterPool.secretRare.push(...pool.secretRare); masterPool.leader.push(...pool.leader);
        if(!masterPool.manga) masterPool.manga = []; masterPool.manga.push(...(pool.manga || []));
        if(!masterPool.altArt) masterPool.altArt = []; masterPool.altArt.push(...(pool.altArt || []));
        if(!masterPool.special) masterPool.special = []; masterPool.special.push(...(pool.special || []));
        if(!masterPool.treasure) masterPool.treasure = []; masterPool.treasure.push(...(pool.treasure || []));
        if(!masterPool.don) masterPool.don = []; masterPool.don.push(...(pool.don || []));
    }

    function countTotal(pool) {
        return pool.common.length + pool.uncommon.length + pool.rare.length + pool.superRare.length + pool.secretRare.length + pool.leader.length + (pool.manga ? pool.manga.length : 0) + (pool.altArt ? pool.altArt.length : 0);
    }

    // --- 6. MENU & NAV ---
    function createMenu() {
        menuBar.innerHTML = "";
        
        // 1. Binder Button
        const binderBtn = document.createElement('button'); 
        binderBtn.className = "set-btn"; 
        binderBtn.innerText = "üìñ MY BINDER"; 
        binderBtn.style.borderColor = "#e74c3c"; 
        binderBtn.onclick = () => toggleBinder(true); 
        menuBar.appendChild(binderBtn);
        
        // Divider
        const sep = document.createElement('span'); 
        sep.innerText = "|"; 
        sep.style.color = "#555"; 
        sep.style.alignSelf = "center"; 
        menuBar.appendChild(sep);
        
        // 2. Set Buttons (Loop)
        setPools.forEach((set, index) => {
            const btn = document.createElement('button'); 
            btn.id = `btn-${index}`; 
            btn.className = "set-btn";
            if (set.error) { 
                btn.classList.add('retry'); 
                btn.innerText = "Retry " + set.name.split(" ")[0]; 
                btn.onclick = () => retryLoad(index); 
            } else { 
                btn.innerText = set.name.split(" ")[0]; 
                btn.onclick = () => selectSet(index); 
            }
            menuBar.appendChild(btn);
        });

        // 3. NEW: Mute Button (Added Here)
        const muteBtn = document.createElement('button');
        muteBtn.id = "muteBtn";
        muteBtn.className = "toggle-btn"; // Uses the smaller button style
        
        // Set initial state based on memory
        if (isMuted) {
            muteBtn.innerText = "üîá Muted";
            muteBtn.style.color = "#e74c3c";
            muteBtn.style.borderColor = "#e74c3c";
        } else {
            muteBtn.innerText = "üîä Sound";
            muteBtn.style.color = "#2ecc71";
            muteBtn.style.borderColor = "#2ecc71";
        }
        muteBtn.onclick = toggleMute;
        menuBar.appendChild(muteBtn);

        // 4. Hide Text Button
        const toggleBtn = document.createElement('button'); 
        toggleBtn.id = "textToggleBtn";
        toggleBtn.className = "toggle-btn"; 
        toggleBtn.innerText = "Hide Text"; 
        toggleBtn.onclick = togglePackText; 
        menuBar.appendChild(toggleBtn);
        
        // 5. Test/Debug Button
        const debugBtn = document.createElement('button'); 
        debugBtn.className = "toggle-btn"; 
        debugBtn.innerText = "üîß TEST"; 
        debugBtn.style.borderColor = "#2ecc71"; 
        debugBtn.style.color = "#2ecc71"; 
        debugBtn.style.display = "none"; 
        debugBtn.onclick = openDebugPack; 
        menuBar.appendChild(debugBtn);
        
        // 6. All Decks Button
        const allBtn = document.createElement('button'); 
        allBtn.className = "set-btn"; 
        allBtn.innerText = "ALL DECKS"; 
        allBtn.style.borderColor = "#ffd700"; 
        allBtn.onclick = () => selectSet(-1); 
        menuBar.appendChild(allBtn);
    }

    function togglePackText() {
        showPackText = !showPackText; packInfo.style.opacity = showPackText ? '1' : '0';
        const btn = document.getElementById('textToggleBtn'); if(btn) btn.innerText = showPackText ? "Hide Text" : "Show Text";
    }
    function toggleMute() {
        isMuted = !isMuted;
        localStorage.setItem('optcg_muted', isMuted); // Save preference
        
        const btn = document.getElementById('muteBtn');
        if (btn) {
            if (isMuted) {
                btn.innerText = "üîá Muted";
                btn.style.color = "#e74c3c";
                btn.style.borderColor = "#e74c3c";
            } else {
                btn.innerText = "üîä Sound";
                btn.style.color = "#2ecc71";
                btn.style.borderColor = "#2ecc71";
                playSound('HOVER'); // Audio feedback when enabling
            }
        }
    }

    function selectSet(index) {
        const hasCards = limboBatches.some(batch => batch !== null && batch.length > 0);
        if (hasCards) {
            if (!confirm("You have unsaved cards on the table! Switching sets will TOSS them. Continue?")) return; 
            limboBatches = []; 
        }

        toggleBinder(false);
        const buttons = document.querySelectorAll('.set-btn'); buttons.forEach(btn => btn.classList.remove('active'));
        const offset = 1; if (index === -1) { if(buttons[buttons.length-1]) buttons[buttons.length-1].classList.add('active'); } else { if(buttons[index + offset]) buttons[index + offset].classList.add('active'); }

        if (index === -1) {
            activePool = masterPool; packTitle.innerText = "ALL DECKS"; packSubtitle.innerText = "Drawing from " + countTotal(masterPool) + " cards";
            document.getElementById('packTop').style.backgroundImage = `url('${PACK_IMAGES.DEFAULT}')`; document.getElementById('packBottom').style.backgroundImage = `url('${PACK_IMAGES.DEFAULT}')`;
        } else {
            if(setPools[index].error) return; 
            activePool = setPools[index].pool; packTitle.innerText = setPools[index].name; packSubtitle.innerText = setPools[index].count + " cards in set";
            const setCode = setPools[index].name.split(" ")[0].replace("-", ""); const imgUrl = PACK_IMAGES[setCode] || PACK_IMAGES.DEFAULT;
            document.getElementById('packTop').style.backgroundImage = `url('${imgUrl}')`; document.getElementById('packBottom').style.backgroundImage = `url('${imgUrl}')`;
        }
        playSound('DROP'); 
        document.getElementById('pack').classList.remove('pack-enter'); void document.getElementById('pack').offsetWidth; document.getElementById('pack').classList.add('pack-enter');
        resetPack();
    }

    // --- HELPER FOR CUSTOM BUTTONS ---
    function adjustPackCount(delta) {
        const input = document.getElementById('packCountInput');
        let val = parseInt(input.value) || 1;
        val += delta;
        
        // Enforce Limits
        if (val < 1) val = 1;
        if (val > 24) val = 24; // Match your max limit
        
        input.value = val;
        updatePackVisuals(); // Refresh the ghost stack immediately
    }

    function toggleColor(color, btnElement) {
        if (activeColors.has(color)) {
            // Remove it
            activeColors.delete(color);
            btnElement.classList.remove('active');
        } else {
            // Add it
            activeColors.add(color);
            btnElement.classList.add('active');
        }
        // Re-render the grid immediately
        renderBinder();
    }

    // --- 7. PACK VISUALS ---
    function updatePackVisuals() {
        const count = parseInt(packCountInput.value) || 1;
        packStack.innerHTML = ''; 
        const stackLimit = Math.min(count - 1, 10); 
        for(let i=0; i<stackLimit; i++) {
            const ghost = document.createElement('div');
            ghost.className = 'pack-stack-item';
            ghost.style.backgroundImage = `url('${PACK_IMAGES.DEFAULT}')`;
            const rot = (Math.random() * 10 - 5) + 'deg'; 
            const xOff = (i * -2) + 'px'; const yOff = (i * -3) + 'px';
            ghost.style.transform = `translate(${xOff}, ${yOff}) rotate(${rot})`;
            ghost.style.zIndex = -1 - i;
            packStack.appendChild(ghost);
        }
    }

    function generatePack() {
        const get = (poolName) => {
            let pool = activePool[poolName]; if (!pool || pool.length === 0) pool = activePool.common; if (!pool || pool.length === 0) return null;
            return pool[Math.floor(Math.random() * pool.length)];
        };
        if (!activePool || (!activePool.common || activePool.common.length === 0)) { alert("Set error."); return []; }

        let scenario = "DOUBLE_RARE"; const roll = Math.random();
        if (roll < 0.60) scenario = "DOUBLE_RARE"; else if (roll < 0.75) scenario = "LEADER_PACK"; else if (roll < 0.95) scenario = "SR_PACK"; else scenario = "BIG_HIT"; 

        const hits = [];
        if (scenario === "DOUBLE_RARE") { hits.push(get('rare')); hits.push(get('rare')); } 
        else if (scenario === "LEADER_PACK") { hits.push(get('leader')); hits.push(get('rare')); hits.push(get('rare')); } 
        else if (scenario === "SR_PACK") { hits.push(get('superRare')); hits.push(get('rare')); } 
        else if (scenario === "BIG_HIT") {
            hits.push(get('rare')); const bigRoll = Math.random();
            if (bigRoll < 0.01) hits.push(get('manga') || get('secretRare')); 
            else if (bigRoll < 0.05) hits.push(get('treasure') || get('special') || get('altArt')); 
            else if (bigRoll < 0.40) hits.push(get('altArt')); else hits.push(get('secretRare')); 
        }

        let addDon = false; if (Math.random() < 0.25) addDon = true; if (scenario === "LEADER_PACK") addDon = false;
        const hasAlt = hits.some(c => c && c.tags && (c.tags.isParallel || c.tags.isSpecial || c.tags.isManga || c.tags.isTreasure));
        if (hasAlt) addDon = false;

        const packCards = [];
        let commonSlots = 12 - 3 - hits.filter(h => h).length - (addDon ? 1 : 0);
        if (commonSlots < 0) commonSlots = 0;

        for(let i=0; i<commonSlots; i++) packCards.push(get('common'));
        if (addDon) { const donCard = get('don'); if (donCard) packCards.push(donCard); else packCards.push(get('common')); }
        for(let i=0; i<3; i++) packCards.push(get('uncommon'));
        hits.forEach(card => { if(card) packCards.push(card); });

        return packCards.filter(c => c !== null && c !== undefined);
    }

    function generateDebugPack() {
        if (!activePool) { alert("Select a set."); return []; }
        const debugCards = [];
        const pools = ['manga', 'treasure', 'altArt', 'special', 'boxTopper', 'secretRare', 'leader', 'superRare', 'rare', 'uncommon', 'common', 'don'];
        pools.forEach(poolName => { if (activePool[poolName] && activePool[poolName].length > 0) debugCards.push(activePool[poolName][0]); });
        return debugCards.filter(c => c !== null && c !== undefined);
    }

    // --- 8. OPENING LOGIC ---
    function openPack() {
        playSound('OPEN');
        packContainer.classList.add('shake-anim');
        
        setTimeout(() => {
            const ghosts = document.querySelectorAll('.pack-stack-item');
            ghosts.forEach(ghost => {
                const rX = (Math.random() * 200 - 100) + 'px'; const rY = (Math.random() * 200 - 100) + 'px'; const rRot = (Math.random() * 60 - 30) + 'deg';
                ghost.style.transition = "all 0.6s ease-out"; ghost.style.opacity = '0'; ghost.style.transform = `translate(${rX}, ${rY}) rotate(${rRot}) scale(1.1)`; 
            });

            packTop.classList.add('ripped-top'); packBottom.classList.add('ripped-bottom'); flashOverlay.classList.add('flash-anim');
            
            setTimeout(() => {
                packWrapper.style.display = 'none'; 
                
                const numPacks = parseInt(packCountInput.value) || 1;
                const isSplit = splitToggle.checked;
                limboBatches = []; 
                
                for(let i=0; i<numPacks; i++) {
                    limboBatches.push(generatePack());
                }

                const delay = numPacks > 10 ? 15 : (numPacks > 1 ? 50 : 300);

                if (isSplit) {
                    cardsArea.innerHTML = '';
                    actionBar.style.display = 'none'; 

                    limboBatches.forEach((batch, batchIdx) => {
                        const groupDiv = document.createElement('div');
                        groupDiv.className = 'pack-group';
                        groupDiv.id = `pack-group-${batchIdx}`;
                        groupDiv.innerHTML = `<div class="pack-group-header">Pack ${batchIdx + 1}</div>`;
                        const gridDiv = document.createElement('div');
                        gridDiv.className = 'pack-group-grid';
                        gridDiv.id = `pack-grid-${batchIdx}`;
                        groupDiv.appendChild(gridDiv);
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'pack-group-actions';
                        actionsDiv.innerHTML = `
                            <button class="action-btn reveal-btn" onclick="flipBatch(${batchIdx})">Reveal</button>
                            <button class="action-btn keep-btn" onclick="keepBatch(${batchIdx})">Keep</button>
                            <button class="action-btn toss-btn" onclick="tossBatch(${batchIdx})">Toss</button>
                        `;
                        groupDiv.appendChild(actionsDiv);
                        cardsArea.appendChild(groupDiv);

                        batch.forEach((card, cardIdx) => {
                            setTimeout(() => {
                                createCardHTML(card, gridDiv, true, 1, false, true);
                                if (numPacks > 10) { if (cardIdx % 4 === 0) playSound('DEAL'); } else { playSound('DEAL'); }
                            }, (batchIdx * 12 + cardIdx) * delay);
                        });
                    });

                } else {
                    cardsArea.innerHTML = '';
                    limboBatches.forEach((batch, batchIdx) => {
                        batch.forEach((card, cardIdx) => {
                            setTimeout(() => {
                                createCardHTML(card, cardsArea, true, 1, false, true);
                                if (numPacks > 10) { if (cardIdx % 4 === 0) playSound('DEAL'); } else { playSound('DEAL'); }
                            }, (batchIdx * 12 + cardIdx) * delay);
                        });
                    });
                    
                    setTimeout(() => { 
                        actionBar.style.display = 'flex';
                        revealBtn.style.display = 'block'; keepBtn.style.display = 'block'; tossBtn.style.display = 'block';
                    }, (limboBatches.flat().length * delay) + 500);
                }
                
            }, DELAY.REVEAL); 
        }, DELAY.SHAKE); 
    }

    function openDebugPack() {
        playSound('OPEN');
        packContainer.classList.add('shake-anim');
        setTimeout(() => {
            packTop.classList.add('ripped-top'); packBottom.classList.add('ripped-bottom'); flashOverlay.classList.add('flash-anim');
            setTimeout(() => {
                packContainer.style.display = 'none';
                limboBatches = [generateDebugPack()]; 
                if(limboBatches[0].length === 0) { alert("Empty set!"); resetPack(); return; }
                
                cardsArea.innerHTML = '';
                limboBatches[0].forEach((card, index) => {
                    setTimeout(() => {
                        createCardHTML(card, cardsArea, true, 1, false, true);
                        playSound('DEAL'); 
                    }, index * 150);
                });
                setTimeout(() => { 
                    actionBar.style.display = 'flex';
                    revealBtn.style.display = 'block'; keepBtn.style.display = 'block'; tossBtn.style.display = 'block';
                }, limboBatches[0].length * 150 + 500);
            }, 400); 
        }, 500);
    }

    // --- BATCH ACTIONS ---
    function flipBatch(batchIdx) {
        const grid = document.getElementById(`pack-grid-${batchIdx}`);
        if(!grid) return;
        const flippers = grid.querySelectorAll('.card-flipper.flipped');
        flippers.forEach((el, index) => {
            setTimeout(() => {
                el.classList.remove('flipped');
                const cardDiv = el.closest('.card');
                const isHit = cardDiv.dataset.isHit === "true";
                const isGodPull = cardDiv.classList.contains('god-pull-flag');
                if(isGodPull) {
                    cardDiv.classList.add('legendary-reveal');
                    const rect = cardDiv.getBoundingClientRect();
                    triggerExplosion(rect.left + rect.width/2, rect.top + rect.height/2);
                }
                playSound(isHit ? 'RARE' : 'FLIP');
            }, index * 50);
        });
        const btn = document.getElementById(`pack-group-${batchIdx}`).querySelector('.reveal-btn');
        if(btn) btn.style.display = 'none';
    }

    function keepBatch(batchIdx) {
        if(!limboBatches[batchIdx]) return;
        limboBatches[batchIdx].forEach(card => {
            const key = card.id && card.id !== "000" ? card.id : card.name;
            if(!userCollection[key]) userCollection[key] = { count: 0, data: card, isNew: true };
            if(!userCollection[key].data) userCollection[key].data = card;
            userCollection[key].count++;
        });
        saveCollection();
        const group = document.getElementById(`pack-group-${batchIdx}`);
        if(group) {
            group.style.transform = "scale(0.5)"; 
            group.classList.add('removing');
            setTimeout(() => group.remove(), 500);
        }
        limboBatches[batchIdx] = null; 
        checkAllProcessed();
    }

    function tossBatch(batchIdx) {
        const group = document.getElementById(`pack-group-${batchIdx}`);
        if(group) {
            group.style.transform = "translateX(200px) rotate(10deg)"; 
            group.classList.add('removing');
            setTimeout(() => group.remove(), 500);
        }
        limboBatches[batchIdx] = null; 
        checkAllProcessed();
    }

    function checkAllProcessed() {
        const remaining = limboBatches.filter(b => b !== null);
        if(remaining.length === 0) setTimeout(resetPack, 600);
    }

    // --- GLOBAL ACTIONS ---
    function keepCards() {
        limboBatches.flat().forEach(card => {
            if(!card) return;
            const key = card.id && card.id !== "000" ? card.id : card.name;
            if(!userCollection[key]) userCollection[key] = { count: 0, data: card, isNew: true };
            if(!userCollection[key].data) userCollection[key].data = card;
            userCollection[key].count++;
        });
        saveCollection();
        limboBatches = []; 
        resetPack();
    }

    function tossCards() { limboBatches = []; resetPack(); }

    function flipAll() {
        const flippers = document.querySelectorAll('.cards-area .card-flipper.flipped');
        
        if(revealBtn) revealBtn.style.display = 'none';

        flippers.forEach((el, index) => {
            setTimeout(() => {
                // 1. FLIP
                el.classList.remove('flipped');
                
                const cardDiv = el.closest('.card');
                
                // 2. RECONSTRUCT CARD DATA FOR IMPACT
                // We grab the rarity class and the God Pull flag to fake the card object
                const rarityClass = Array.from(cardDiv.classList).find(c => c.startsWith('rarity-'));
                const isGodPull = cardDiv.classList.contains('god-pull-flag');
                
                const dummyCard = {
                    rarity: rarityClass ? rarityClass.replace('rarity-', '') : 'C',
                    tags: {
                        isManga: isGodPull, 
                        isTreasure: isGodPull,
                        isSpecial: isGodPull,
                        isGoldDon: isGodPull,
                        isParallel: rarityClass === 'rarity-SR' 
                    },
                    name: "Reveal All Card", 
                    image: cardDiv.querySelector('img').src
                };

                const rect = cardDiv.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // 3. TRIGGER IMPACT (WITH SUPPRESSION)
                // true = Don't show the Wanted Poster overlay
                triggerImpact(dummyCard, centerX, centerY, true);
                
                // 4. PLAY SOUND
                const isHit = cardDiv.dataset.isHit === "true";
                if (!isHit) playSound('FLIP');

            }, index * 150); 
        });
    }

    function resetPack() {
        cardsArea.innerHTML = '';
        packWrapper.style.display = 'block'; packContainer.style.display = 'block'; 
        packContainer.classList.remove('shake-anim'); packTop.classList.remove('ripped-top'); packBottom.classList.remove('ripped-bottom'); flashOverlay.classList.remove('flash-anim');
        actionBar.style.display = 'none';
        hideTooltip(); 
        playSound('DROP');
        document.getElementById('pack').classList.remove('pack-enter'); void document.getElementById('pack').offsetWidth; document.getElementById('pack').classList.add('pack-enter');
        updatePackVisuals(); 
    }

    // --- 8. COLLECTION LOGIC ---
    function saveCollection() { 
        const minimalSave = {};
        Object.keys(userCollection).forEach(key => {
            if(userCollection[key] && userCollection[key].data) minimalSave[key] = { count: userCollection[key].count, isNew: userCollection[key].isNew, setID: userCollection[key].data.setID };
        });
        try { localStorage.setItem('optcg_collection', JSON.stringify(minimalSave)); } catch(e) { console.error("Storage full!", e); }
    }
    
    function exportSave() {
        const exportData = {};
        Object.keys(userCollection).forEach(key => {
            if(userCollection[key] && userCollection[key].data) exportData[key] = { count: userCollection[key].count, isNew: userCollection[key].isNew, data: userCollection[key].data };
        });
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData));
        const downloadAnchorNode = document.createElement('a'); const date = new Date().toISOString().split('T')[0];
        downloadAnchorNode.setAttribute("href", dataStr); downloadAnchorNode.setAttribute("download", "optcg_save_" + date + ".json");
        document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
    }

    function importSave(input) {
        const file = input.files[0]; if(!file) return;
        if(!confirm("Loading a file will OVERWRITE your current collection. Are you sure?")) { input.value = ''; return; }
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const rawSave = JSON.parse(e.target.result); userCollection = {}; 
                Object.keys(rawSave).forEach(key => {
                    const savedItem = rawSave[key];
                    if (savedItem.data) {
                        userCollection[key] = { count: savedItem.count, isNew: savedItem.isNew, data: savedItem.data };
                        if(!userCollection[key].data.tags) userCollection[key].data.tags = analyzeTags(userCollection[key].data.name, "", userCollection[key].data.extendedData);
                    }
                });
                if(Object.keys(userCollection).length > 0) saveCollection(); 
                renderBinder(); alert("Collection imported successfully!");
            } catch(err) { alert("Error reading file: " + err); }
        };
        reader.readAsText(file);
    }

    function wipeCollection() {
        if(confirm("Are you sure? This will delete all your collected cards.")) {
            userCollection = {};
            saveCollection();
            renderBinder(); 
            collectionStats.innerText = "Total: 0";
            binderGrid.innerHTML = '<div style="color:#888; margin-top:50px;">Collection Reset.</div>';
        }
    }

    function toggleBinder(show) {
        if(show) { gameView.style.display = 'none'; binderView.style.display = 'flex'; renderBinder(); } 
        else { 
            try { Object.values(userCollection).forEach(item => { if(item) item.isNew = false; }); saveCollection(); } catch(e) {}
            gameView.style.display = 'flex'; binderView.style.display = 'none'; hideTooltip(); 
        }
    }

    function renderBinder() {
        // 1. SETUP & CLEAR
        binderGrid.innerHTML = ''; 
        binderStats.innerHTML = '';
        
        const setVal = filterSet.value; 
        const rarVal = filterRarity.value; 
        const sortVal = document.getElementById('sortOrder') ? document.getElementById('sortOrder').value : "RARITY"; // Safety check
        const searchVal = binderSearch ? binderSearch.value.toLowerCase().trim() : "";
        
        // 2. CALCULATE STATISTICS (Set Completion)
        const uniqueOwnedBySet = {};
        Object.values(userCollection).forEach(item => {
            if(!item || !item.data) return;
            const sid = item.data.setID; const dispNum = item.data.displayNumber; 
            if(!uniqueOwnedBySet[sid]) uniqueOwnedBySet[sid] = new Set();
            uniqueOwnedBySet[sid].add(dispNum);
        });

        setPools.forEach(sp => {
            if(!sp.error) {
                const targetPrefix = sp.name.split(" ")[0].replace("-", ""); 
                const allPools = ['common','uncommon','rare','superRare','secretRare','leader','manga','altArt','boxTopper','special','treasure','don'];
                const strictSetNumbers = new Set();
                
                allPools.forEach(pKey => {
                    if(sp.pool[pKey]) {
                        sp.pool[pKey].forEach(c => {
                            if(c.setID === targetPrefix) {
                                const numEntry = c.extendedData.find(i => i.name === "Number");
                                if(numEntry) strictSetNumbers.add(numEntry.value);
                            }
                        });
                    }
                });
                
                const total = strictSetNumbers.size;
                const owned = uniqueOwnedBySet[targetPrefix] ? uniqueOwnedBySet[targetPrefix].size : 0;
                
                if(total > 0) {
                    // Highlight completed sets
                    const style = owned === total ? 'style="border-color:#2ecc71; color:#2ecc71;"' : '';
                    binderStats.innerHTML += `<div class="set-stat-pill" ${style}>${sp.name.split(" ")[0]}: <span>${owned}/${total}</span></div>`;
                }
            }
        });
        if(uniqueOwnedBySet['OTHER']) binderStats.innerHTML += `<div class="set-stat-pill">OTHER: <span>${uniqueOwnedBySet['OTHER'].size}</span></div>`;

        // 3. FILTERING LOGIC
        let keys = Object.keys(userCollection).filter(key => {
            const item = userCollection[key];
            if(!item || !item.data) return false;
            const card = item.data;
            
            // A. Set Filter
            if (setVal !== "ALL" && card.setID !== setVal) return false;
            
            // B. Search Filter
            if (searchVal !== "" && !card.name.toLowerCase().includes(searchVal)) return false;

            // C. Color Filter (Multi-Select)
            if (activeColors.size > 0) {
                const colorData = card.extendedData ? card.extendedData.find(d => d.name === "Color") : null;
                const colorStr = colorData ? colorData.value : "";
                if (!colorStr) return false;

                // Check if card matches AT LEAST ONE active color
                let hasMatch = false;
                activeColors.forEach(c => {
                    if (colorStr.includes(c)) hasMatch = true;
                });
                if (!hasMatch) return false;
            }

            // D. Rarity Filter
            if (rarVal !== "ALL") {
                const r = card.rarity.toUpperCase(); const t = card.tags || {}; 
                if (rarVal === "MANGA") return t.isManga;
                if (rarVal === "AA") return t.isParallel;
                if (rarVal === "TREASURE") return t.isTreasure;
                if (rarVal === "SPECIAL") return t.isSpecial || t.isBoxTopper;
                if (rarVal === "DON") return card.backType === 'DON';
                if (rarVal === "SEC" && !(r.includes("SEC") || r.includes("TR"))) return false;
                if (rarVal === "L" && !(r.includes("LEADER") || r === "L")) return false;
                if (rarVal === "SR" && !(r.includes("SUPER") || r === "SR")) return false;
                if (rarVal === "R" && !(r.includes("RARE") || r === "R")) return false;
                if (rarVal === "UC" && !(r.includes("UNCOMMON") || r === "UC")) return false;
                if (rarVal === "C" && r !== "C" && r !== "COMMON") return false;
            }
            return true;
        });

        // Update UI Text
        collectionStats.innerText = `Showing: ${keys.length} Cards`;
        
        // Handle Empty State
        if(keys.length === 0) { 
            binderGrid.innerHTML = '<div style="color:#888; margin-top:50px; font-size:1.2em;">No cards found matching filters.</div>'; 
            return; 
        }

        // 4. SORTING LOGIC
        keys.sort((a,b) => {
            const itemA = userCollection[a]; const itemB = userCollection[b];
            const cardA = itemA.data; const cardB = itemB.data;

            // A. Sort by Price (Bounty)
            if (sortVal === "PRICE_DESC" || sortVal === "PRICE_ASC") {
                const priceA = cardA.marketPrice || 0;
                const priceB = cardB.marketPrice || 0;
                if (priceA !== priceB) {
                    return sortVal === "PRICE_DESC" ? priceB - priceA : priceA - priceB;
                }
            }

            // B. Sort by Date (Newest)
            if (sortVal === "NEWEST") {
                if (itemA.isNew !== itemB.isNew) return itemA.isNew ? -1 : 1;
            }

            // C. Rank Helper (For Rarity Sort)
            const getRank = (c) => {
                const t = c.tags || {};
                if(t.isManga) return 10; if(t.isTreasure) return 9.5; if(t.isSpecial || t.isSignature) return 9; if(t.isParallel) return 8; 
                if(c.rarity.includes("SEC") || c.rarity.includes("TR")) return 6; if(c.rarity.includes("LEADER") || c.rarity === "L") return 5;
                if(c.rarity.includes("SUPER") || c.rarity === "SR") return 4; if(c.rarity.includes("RARE") || c.rarity === "R") return 3;
                if(c.rarity.includes("UNCOMMON") || c.rarity === "UC") return 2; return 1;
            };
            
            // Only apply Rank sort if explicitly requested OR as a tie-breaker for Price
            if (sortVal === "RARITY" || sortVal === "PRICE_DESC" || sortVal === "PRICE_ASC") {
                const rankA = getRank(cardA); const rankB = getRank(cardB);
                if (rankA !== rankB) return rankB - rankA; 
            }

            // D. Sort by Card Number (Universal Tie-Breaker)
            // 1. Sort by Set ID first (OP01 before OP02)
            if (cardA.setID !== cardB.setID) return String(cardA.setID).localeCompare(String(cardB.setID));
            
            // 2. Sort by Number (The Crash Fix: Wrap in String())
            return String(cardA.displayNumber).localeCompare(String(cardB.displayNumber), undefined, { numeric: true, sensitivity: 'base' });
        });

        // 5. RENDER CARDS
        // --- OPTIMIZED RENDER (Infinite Scroll) ---
        
        // 1. Save the full list to global state
        currentBinderKeys = keys;
        renderedCount = 0;
        
        // 2. Clear Grid
        // (This is already done at top of function, but safe to ensure)
        binderGrid.innerHTML = ''; 

        // 3. Render First Batch immediately
        renderNextBatch();
    }

    function triggerExplosion(x, y, customColors, particleCount) {
        const colors = customColors || ['#FFD700', '#FFA500', '#FF4500', '#FFFFFF', '#00BFFF'];
        const count = particleCount || 40;

        for (let i = 0; i < count; i++) {
            const p = document.createElement('div');
            p.classList.add('particle');
            p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            
            // FIX: Center the particle (8px wide -> subtract 4px)
            // This aligns the CENTER of the particle with your X/Y coordinates
            p.style.left = (x - 4) + 'px'; 
            p.style.top = (y - 4) + 'px';
            
            const velocity = 50 + Math.random() * (count * 4); 
            const angle = Math.random() * Math.PI * 2; 
            
            const tx = Math.cos(angle) * velocity + 'px'; 
            const ty = Math.sin(angle) * velocity + 'px';
            
            p.style.setProperty('--tx', tx); 
            p.style.setProperty('--ty', ty);
            
            const scale = 0.5 + Math.random();
            p.style.transform = `scale(${scale})`;

            document.body.appendChild(p); 
            setTimeout(() => p.remove(), 1000);
        }
    }

    // --- IMPACT ENGINE (Updated for Smooth "Reveal All") ---
    function triggerImpact(card, x, y, suppressOverlay = false) {
        if (!card) return;

        // 1. DETERMINE TIER
        let tier = 0;
        const r = card.rarity.toUpperCase();
        const t = card.tags || {};

        if (r.includes('RARE') || r === 'R') tier = 1;
        if (r.includes('SUPER') || r === 'SR' || t.isParallel) tier = 2;
        if (r.includes('LEADER') || r === 'L' || r.includes('SECRET') || r === 'SEC') tier = 3;
        if (t.isManga || t.isTreasure || t.isSpecial || t.isSignature || t.isGoldDon) tier = 4;

        if (tier === 0) return; 

        // 2. EXECUTE EFFECTS

        // --- LEVEL 1: RARE (Tier 1) ---
        if (tier === 1) {
            triggerExplosion(x, y, ['#00BFFF', '#ffffff'], 20); 
            triggerFlash('flash-anim-fast'); 
            
            playSound('HIT_R'); // <--- Light Metallic Ping
            
            if (navigator.vibrate) navigator.vibrate(50);
        }

        // --- LEVEL 2: SUPER RARE (Tier 2) ---
        else if (tier === 2) {
            triggerExplosion(x, y, ['#FFD700', '#FFA500', '#ffffff'], 50); 
            triggerFlash('flash-anim-med');
            
            playSound('HIT_SR'); // <--- Magical Chime
            
            if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
        }

        // --- LEVEL 3: SECRET / LEADER (Tier 3) ---
        else if (tier === 3) {
            triggerExplosion(x, y, ['#FF0000', '#FFD700', '#000000'], 100); 
            triggerFlash('flash-anim-med');
            
            const view = document.getElementById('game-view');
            view.classList.add('shake-screen'); 
            setTimeout(() => view.classList.remove('shake-screen'), 500);
            
            playSound('HIT_SEC'); // <--- Heavy Bass Impact
            
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        }

        // --- LEVEL 4: MANGA / GOD (Tier 4) ---
        else if (tier === 4) {
            // Massive Explosion always happens
            triggerExplosion(x, y, ['#FFFFFF', '#FFD700', '#00FFFF', '#FF00FF'], 200); 
            triggerFlash('flash-anim-long'); 
            
            const view = document.getElementById('game-view');
            view.classList.add('shake-screen');
            setTimeout(() => {
                view.classList.remove('shake-screen');
                void view.offsetWidth; 
                view.classList.add('shake-screen');
            }, 500);
            
            playSound('HIT_GOD'); // <--- The "Holy Grail" Sound
            
            if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 500]);

            // Only show the Poster Overlay if NOT in "Reveal All" mode
            if (!suppressOverlay) {
                setTimeout(() => {
                    showWantedPoster(card);
                }, 400);
            }
        }
    }

    // Helper: Variable Flash
    function triggerFlash(animClass) {
        const flash = document.getElementById('flashOverlay');
        flash.className = 'flash-overlay'; // Reset
        void flash.offsetWidth; // Reflow
        flash.classList.add(animClass);
    }

    function showWantedPoster(card) {
        const overlay = document.getElementById('wantedOverlay');
        const imgSlot = document.getElementById('wantedImageSlot');
        const nameSlot = document.getElementById('wantedName');
        const valSlot = document.getElementById('wantedValue');

        // Set Data
        imgSlot.innerHTML = `<img src="${card.image}">`;
        nameSlot.innerText = card.name;
        
        // --- REAL BOUNTY LOGIC ---
        let bountyVal = 0;
        
        // 1. If we have a real market price, convert to Berries
        // Multiplier: $1.00 = 1,000,000 Berries
        if (card.marketPrice && card.marketPrice > 0) {
            bountyVal = Math.floor(card.marketPrice * 1000000);
        } else {
            // 2. Fallback for offline/unpriced cards (Random 100M - 4B)
            bountyVal = Math.floor(Math.random() * (4000000000 - 100000000) + 100000000);
        }

        // Format with commas (e.g., "3,000,000,000")
        valSlot.innerText = bountyVal.toLocaleString();

        // Show
        overlay.style.display = 'flex';
        playSound('DROP'); 
    }

    function closeWanted() {
        document.getElementById('wantedOverlay').style.display = 'none';
    }

    function createCardHTML(card, container, isPackOpening, quantity = 1, isNew = false, startFlipped = false, isBinder = false) {
        if(!card) return; 
        const cardDiv = document.createElement('div');
        let rarityClass = 'rarity-C'; let glareClass = 'glare-basic'; const r = card.rarity.toUpperCase();
        let isHit = false; let isGodPull = false; 

        // --- RARITY & GLARE LOGIC ---
        if (r === 'UC' || r.includes('UNCOMMON')) { rarityClass = 'rarity-UC'; }
        else if (r === 'SR' || r.includes('SUPER')) { rarityClass = 'rarity-SR'; glareClass = 'glare-super'; isHit = true; }
        else if (r === 'SEC' || r.includes('SECRET')) { rarityClass = 'rarity-SEC'; glareClass = 'glare-secret'; isHit = true; }
        else if (r === 'L' || r.includes('LEADER')) { rarityClass = 'rarity-L'; glareClass = 'glare-secret'; isHit = true; }
        else if (r === 'R' || r.includes('RARE')) { rarityClass = 'rarity-R'; glareClass = 'glare-rare'; }
        else if (r === 'TR' || r === 'SPECIAL') { rarityClass = 'rarity-SEC'; glareClass = 'glare-secret'; isHit = true; }

        if (card.tags) {
            if (card.tags.isManga) { rarityClass = 'rarity-SEC'; glareClass = 'glare-secret'; isGodPull = true; isHit = true; }
            if (card.tags.isTreasure) { rarityClass = 'rarity-SEC'; glareClass = 'glare-secret'; isGodPull = true; isHit = true; }
            if (card.tags.isSpecial) { isGodPull = true; isHit = true; }
            if (card.tags.isSignature) { isGodPull = true; isHit = true; }
            if (card.tags.isParallel) { isGodPull = true; isHit = true; }
            
            // Gold Don Logic
            if (card.tags.isGoldDon) {
                rarityClass = 'rarity-SR';   
                glareClass = 'glare-secret'; 
                isGodPull = true;            
                isHit = true;
            }
        }

        // --- BUILD CARD CONTAINER ---
        cardDiv.className = `card ${rarityClass}`;
        if(isGodPull) cardDiv.classList.add('god-pull-flag'); 
        cardDiv.dataset.isHit = isHit; 
        cardDiv.style.display = 'block';
        
        const tilter = document.createElement('div'); tilter.className = 'card-tilter';
        const flipper = document.createElement('div'); flipper.className = 'card-flipper';
        if (startFlipped) flipper.classList.add('flipped');
        if(isPackOpening) { cardDiv.style.animation = 'popIn 0.5s ease-out forwards'; }

        // --- BACK IMAGE LOGIC ---
        let backType = card.backType;
        if (!backType || backType === "GENERIC" || backType === "undefined") { backType = determineBackType(card.rarity, card.extendedData); }
        let backImg = CARD_BACKS.GENERIC;
        if(backType === 'LEADER') backImg = CARD_BACKS.LEADER;
        if(backType === 'DON') backImg = CARD_BACKS.DON;

        // --- MOUSE EVENTS (Tilt + Tooltip) ---
        cardDiv.onmouseenter = (e) => {
            // Mobile Check
            if (typeof gyroActive !== 'undefined' && gyroActive) return; 
            
            playSound('HOVER');
            cardDiv.style.animation = 'none'; 
            activeCardRect = cardDiv.getBoundingClientRect();
            tilter.style.transition = 'none';

            // TOOLTIP LOGIC
            // Allow if: (It is Binder Mode) OR (The card is Face Up)
            // Note: .flipped class means the BACK is showing.
            const isFaceUp = !flipper.classList.contains('flipped');
            
            if ((isBinder || isFaceUp) && typeof scheduleTooltip === 'function') {
                scheduleTooltip(card, e);
            }
        };

        cardDiv.onmousemove = (e) => {
            // Mobile Check
            if (typeof gyroActive !== 'undefined' && gyroActive) return;
            if(!activeCardRect) return;
            
            // 1. Tilt Effect
            tiltCard(e, tilter, flipper); 
            
            // 2. Tooltip Movement
            // We check the element directly to ensure smooth tracking
            const tooltipEl = document.getElementById('cardTooltip');
            if (tooltipEl && tooltipEl.style.display === 'block') {
                moveTooltip(e.pageX, e.pageY);
            }
        };

        cardDiv.onmouseleave = () => {
            // TOOLTIP STOP
            if (typeof cancelTooltip === 'function') cancelTooltip();

            // Reset Tilt
            if (typeof hideTooltip === 'function') hideTooltip(); 
            resetCard(tilter);
            activeCardRect = null;
        };

        // --- CLICK EVENTS (Modal vs Reveal) ---
        cardDiv.onclick = (e) => {
            // 1. Binder Logic: Open High-Res Modal
            if (isBinder) { 
                if (typeof cancelTooltip === 'function') cancelTooltip(); 
                openPreviewModal(card); 
                return; 
            }

            // 2. Pack Opening Logic: Reveal/Hide
            if(flipper.classList.contains('flipped')) {
                // REVEAL
                flipper.classList.remove('flipped'); 
                
                const rect = cardDiv.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                if (typeof triggerImpact === 'function') triggerImpact(card, centerX, centerY); 
                playSound('FLIP');
                
                cardDiv.classList.remove('legendary-reveal'); 
                if (typeof hideTooltip === 'function') hideTooltip();

            } else {
                // HIDE
                flipper.classList.add('flipped'); 
                playSound('FLIP');
                
                if (typeof hideTooltip === 'function') hideTooltip();
                
                // Hide "Reveal All" button if everything is open
                if(document.querySelectorAll('.card-flipper:not(.flipped)').length === 0) { 
                    const mainBtn = document.getElementById('revealBtn');
                    if(mainBtn) mainBtn.style.display = 'none'; 
                    
                    const localBtn = cardDiv.closest('.pack-group')?.querySelector('.reveal-btn');
                    if(localBtn) localBtn.style.display = 'none';
                }
            }
        };

        // --- ASSEMBLE HTML ---
        const badgeText = card.displayNumber || card.id;
        let badgeHTML = `<div class="card-rarity-badge">${badgeText}</div>`;
        if(quantity > 1) badgeHTML += `<div class="count-badge">x${quantity}</div>`;
        if(isNew) badgeHTML += `<div class="new-badge">NEW!</div>`;

        const front = document.createElement('div'); front.className = 'card-front';
        front.innerHTML = `<div class="card-glare ${glareClass}"></div><img src="${card.image}" onerror="this.src='https://placehold.co/200x280?text=Image+Blocked'" style="width:100%; height:100%; object-fit:cover;">${badgeHTML}`;
        
        const back = document.createElement('div'); back.className = 'card-back';
        back.style.backgroundImage = `url('${backImg}')`;

        flipper.appendChild(front); flipper.appendChild(back); tilter.appendChild(flipper); cardDiv.appendChild(tilter); container.appendChild(cardDiv);
    }

    function renderNextBatch() {
        // Stop if we have shown everything
        if (renderedCount >= currentBinderKeys.length) return;

        // Calculate the slice
        const nextBatch = currentBinderKeys.slice(renderedCount, renderedCount + BATCH_SIZE);
        
        // Render them
        nextBatch.forEach(key => {
            const item = userCollection[key];
            if (item) {
                createCardHTML(item.data, binderGrid, false, item.count, item.isNew, false, true);
            }
        });

        // Update counter
        renderedCount += nextBatch.length;

        // Update the Sentinel (The invisible line at the bottom)
        updateScrollSentinel();
    }

    function updateScrollSentinel() {
        // 1. Remove old sentinel if it exists
        const old = document.getElementById('binder-sentinel');
        if (old) old.remove();

        // 2. If we still have cards to show, add a new sentinel
        if (renderedCount < currentBinderKeys.length) {
            const sentinel = document.createElement('div');
            sentinel.id = 'binder-sentinel';
            sentinel.style.height = '100px'; 
            sentinel.style.width = '100%';
            // sentinel.style.backgroundColor = 'red'; // Uncomment to debug/see the line
            binderGrid.appendChild(sentinel);

            // 3. Observe it
            if (binderScrollObserver) binderScrollObserver.disconnect();
            
            binderScrollObserver = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting) {
                    renderNextBatch();
                }
            }, { root: null, rootMargin: '400px' }); // Load when within 400px of bottom

            binderScrollObserver.observe(sentinel);
        }
    }

    // --- BULLETPROOF TOOLTIP SYSTEM ---
    
    let tooltipTimer = null; 

    function showTooltip(card) {
        const tooltipEl = document.getElementById('cardTooltip');
        if (!tooltipEl) return;

        // --- HELPER: Safe Data Extraction ---
        const safeGet = (key) => {
            if (!card.extendedData || !Array.isArray(card.extendedData)) return '';
            const item = card.extendedData.find(d => d.name === key || d.name === key + "+"); // Handles "Counter" vs "Counter+"
            return item ? item.value : '';
        };

        // --- HELPER: Build HTML Row ---
        const buildRow = (label, value) => {
            if (!value || value === 'N/A' || value === 'undefined') return ''; 
            return `
                <div class="tooltip-row">
                    <span class="tooltip-label">${label}:</span>
                    <span class="tooltip-val">${value}</span>
                </div>`;
        };

        // --- 1. GATHER DATA ---
        const number   = safeGet("Number") || card.number || '???';
        const rarity   = safeGet("Rarity");
        const color    = safeGet("Color");
        const cardType = safeGet("CardType");
        const life     = safeGet("Life");
        const power    = safeGet("Power");
        const counter  = safeGet("Counter") || safeGet("Counter+"); // NEW: Counter Logic
        const attribute= safeGet("Attribute");
        const cost     = safeGet("Cost");
        let subtypes   = safeGet("Subtypes");
        let desc       = safeGet("Description") || safeGet("Effect");

        // --- 2. FORMATTING ---
        if (subtypes && subtypes.includes(';')) {
            subtypes = subtypes.replace(/;/g, ' / ');
        }
        
        let extraInfo = '';
        if (card.tags && card.tags.isParallel) extraInfo = ' <span style="color:#aaa; font-size:0.8em">(Alt Art)</span>';

        // --- 3. BUILD HTML ---
        
        // Header: Name Only (Number moved down)
        let html = `<div class="tooltip-header">${card.name}${extraInfo}</div>`;

        // Row 1: Number & Rarity
        html += buildRow('Number', number);
        html += buildRow('Rarity', rarity);
        
        html += buildRow('Color', color);
        html += buildRow('Card Type', cardType);

        // Life vs Cost
        if (life) { html += buildRow('Life', life); } 
        else { html += buildRow('Cost', cost); }

        html += buildRow('Power', power);
        html += buildRow('Counter+', counter); // NEW ROW
        html += buildRow('Subtype(s)', subtypes);
        html += buildRow('Attribute', attribute);

        // Description
        if (desc) {
             const formattedDesc = desc.replace(/\n/g, '<br>');
             html += `
                <div class="tooltip-desc-container">
                    <span class="tooltip-desc-title">Description</span>
                    <div class="tooltip-desc-text">${formattedDesc}</div>
                </div>`;
        }

        tooltipEl.innerHTML = html;
        tooltipEl.style.display = 'block';
    }

    function hideTooltip() {
        const tooltipEl = document.getElementById('cardTooltip');
        if (tooltipEl) tooltipEl.style.display = 'none';
    }

    function moveTooltip(x, y) {
        const tooltipEl = document.getElementById('cardTooltip');
        if (!tooltipEl || tooltipEl.style.display === 'none') return;
        
        const pad = 20; // Distance from cursor
        let newLeft = x + pad;
        let newTop = y + pad;

        // --- EDGE DETECTION (Viewport Aware) ---
        const rect = tooltipEl.getBoundingClientRect();
        const winW = window.innerWidth;
        const winH = window.innerHeight;

        // 1. Check Right Edge
        // If (Cursor X + Tooltip Width) > Screen Width
        if (newLeft + rect.width > winW) {
            // Flip to left side of cursor
            newLeft = x - rect.width - pad;
        }

        // 2. Check Bottom Edge
        // If (Cursor Y + Tooltip Height) > Screen Height
        if (newTop + rect.height > winH) {
            // Flip to above cursor
            newTop = y - rect.height - pad;
        }

        // 3. Force-Contain (Safety net for mobile/small screens)
        // Ensure it never goes off the top or left edge
        if (newLeft < 0) newLeft = pad;
        if (newTop < 0) newTop = pad;

        tooltipEl.style.left = newLeft + 'px';
        tooltipEl.style.top = newTop + 'px';
    }

    // --- TIMER LOGIC (With Coordinate Capture) ---
    function scheduleTooltip(card, event) {
        if (tooltipTimer) clearTimeout(tooltipTimer);
        hideTooltip(); 

        // NO LONGER capturing event.pageX here. 
        // We will use the global variables when the timer fires.

        tooltipTimer = setTimeout(() => {
            // Safety check: Ensure mouse is still over the card?
            // Actually, your onmouseleave handles the cancellation. 
            // If the timer fires, it means we are still hovering.
            
            showTooltip(card);
            
            // SPAWN AT CURRENT MOUSE POSITION
            moveTooltip(globalMouseX, globalMouseY); 
        }, 1500); 
    }

    function cancelTooltip() {
        if (tooltipTimer) clearTimeout(tooltipTimer);
        hideTooltip();
    }
    // --- UNIFIED VISUALS HELPER (Fixed Scale & Smooth Glare) ---
    function updateCardVisuals(tilter, rotateX, rotateY) {
        if (!tilter) return;

        // 1. Apply Physical Rotation + Scale
        // CHANGED: Increased scale from 1.02 to 1.1 so it visibly "pops" again
        tilter.style.transform = `scale(1.1) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

        // 2. Calculate Glare (Reflection Logic)
        const maxAngle = 20; 

        // CHANGED: Removed the "1.5" multiplier. 
        // Now the glare will hit the edge exactly when the tilt hits the max angle.
        // No more "sticking" or dead zones.
        
        let glareX = 50 + ((rotateY / maxAngle) * 50); 
        let glareY = 50 - ((rotateX / maxAngle) * 50);

        // Clamp values (0% - 100%)
        glareX = Math.max(0, Math.min(100, glareX));
        glareY = Math.max(0, Math.min(100, glareY));

        // 3. Set CSS Variables
        tilter.style.setProperty('--pointer-x', glareX);
        tilter.style.setProperty('--pointer-y', glareY);
    }

    // --- MOUSE TILT FUNCTION ---
    function tiltCard(e, tilterDiv, flipperDiv) {
        // Safety Check
        if (!activeCardRect) return;

        // 1. Calculate Mouse Position relative to card center
        const x = e.clientX - activeCardRect.left; 
        const y = e.clientY - activeCardRect.top;
        const centerX = activeCardRect.width / 2; 
        const centerY = activeCardRect.height / 2;

        // 2. Calculate Angle (Max 20 degrees)
        // Invert X so moving mouse DOWN tilts card DOWN (negative rotation)
        const rotateX = ((y - centerY) / centerY) * -20; 
        const rotateY = ((x - centerX) / centerX) * 20;

        // 3. Hand off to Helper
        updateCardVisuals(tilterDiv, rotateX, rotateY);
    }
    function resetCard(tilterDiv) { tilterDiv.style.transition = 'transform 0.5s ease-out'; tilterDiv.style.transform = `scale(1) rotateX(0deg) rotateY(0deg)`; }

    function openPreviewModal(card) {
        const overlay = document.getElementById('cardPreviewOverlay');
        const img = document.getElementById('previewImage');
        const title = document.getElementById('previewTitle');
        const price = document.getElementById('previewPrice');

        // 1. GENERATE HIGH-RES URL
        // TCGPlayer Logic: Replace '_200w' with '_in_1000x1000'
        let highResUrl = card.image;
        if (highResUrl.includes('_200w.jpg')) {
            highResUrl = highResUrl.replace('_200w.jpg', '_in_1000x1000.jpg');
        }

        // 2. SET CONTENT
        img.src = highResUrl;
        title.innerText = card.name;
        
        // Format price nicely
        const pVal = card.marketPrice || card.price || 0;
        price.innerText = pVal > 0 ? `$${pVal.toFixed(2)}` : "Market Price Unavailable";

        // 3. SHOW
        overlay.style.display = 'flex';
        playSound('HOVER'); 
    }

    function closePreview() {
        document.getElementById('cardPreviewOverlay').style.display = 'none';
    }

    // --- GYROSCOPE PERMISSION & LOGIC ---
    function requestGyro() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ Logic
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        startGyro();
                        document.getElementById('gyroBtn').style.display = 'none'; // Hide button after success
                    } else {
                        alert("Permission denied. Tilt effects disabled.");
                    }
                })
                .catch(console.error);
        } else {
            // Android / Non-iOS Logic
            startGyro();
            document.getElementById('gyroBtn').style.display = 'none';
        }
    }

    function startGyro() {
        // LOCK OUT MOUSE EVENTS
        gyroActive = true; 

        window.addEventListener("deviceorientation", (event) => {
            // 1. Get Angles from Phone
            let tiltX = event.gamma; // Left/Right Tilt (-90 to 90)
            let tiltY = event.beta;  // Front/Back Tilt (-180 to 180)

            // 2. Constraints (Prevent flipping too far)
            if (tiltX > 30) tiltX = 30;
            if (tiltX < -30) tiltX = -30;
            if (tiltY > 40) tiltY = 40;
            if (tiltY < 0) tiltY = 0;

            // 3. Convert Phone Tilt to Card Rotation Angles
            // We want the card to rotate roughly -20deg to +20deg based on your hand movement.
            
            // Map Left/Right (Gamma) directly to Y-Axis Rotation
            const rotateY = (tiltX / 30) * 20; 

            // Map Front/Back (Beta) to X-Axis Rotation
            // We center it around 20 degrees so holding the phone naturally feels "flat"
            const rotateX = ((tiltY - 20) / 20) * -20; 

            // 4. Batch Update DOM
            requestAnimationFrame(() => {
                const visibleCards = document.querySelectorAll('.card');
                visibleCards.forEach(card => {
                    const tilter = card.querySelector('.card-tilter');
                    if(tilter) {
                        // Hand off to the Helper Function to calculate Glare & Transform
                        updateCardVisuals(tilter, rotateX, rotateY);
                    }
                });
            });
        }, true);
    }

    // Auto-detect if we need the button
    // If it's iOS, show the button. If Android, try to start immediately.
    if (window.DeviceOrientationEvent && 'ontouchstart' in window) {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyroBtn').style.display = 'inline-block'; // Show button for iOS
        } else {
            startGyro(); // Try auto-start for Android
        }
    }

    init();
</script>
</body>
</html>